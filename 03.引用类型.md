##引用类型

- 创建对象的两种方式
	- 构造函数 `new Object()`
	- 对象字面量 `var obj = {}`
- 除非使用变量访问属性（`obj[variable]`），都用 `.` 访问
- 使用 `new` 操作符创建的引用类型实例，在执行流离开当前作用域之前都一直保存在内存中

###Array类型

- 创建数组的两种方式
	- 使用Array构造函数 `var arr = new Array();`
		- 指定array长度 `var arr = new Array(20);`
		- 指定array项目 `var arr = new Array('a','b','c');`
		- 可以省略 `new` 操作符
	- 使用数组字面量创建
		- 不要留空 ~~[1,2,,]~~
- 使用`[]`访问数组中的值，如果索引小于长度，返回索引对应的值，反之自动增加数组长度到索引+1的长度
- `array.length` 可以设置数组长度，被删除或增加的项目都是undefined
- `array[array.length] = foo` 向数组最后增加值
- 检测数组 `arr instanceof Array`
	- 问题：`instanceof` 假定只有一个全局执行环境，如果包含多个框架从而有可能存在两个以上不同版本的Array构造函数
	- ES5新增：`Array.isArray(arr)`
	- `Object.prototype.toString.apply(arr) === '[object Array]'`
- 转换方法
	- `toString()`，`valueOf()` 每个值的字符串拼接，以 `,` 分割
	- `join()` 使用不同分隔符 `[1,2,3].join('|') = '1|2|3'`
	- 如果数组中的某一项为空，则转换操作都返回空字符串
- 栈方法 （last-in-first-out）
	- `push()` 向数组最后添加一个值，返回并改变长度
	- `pop()` 从数组最后移除一个值，返回移除的项，并改变长度

```js
var colors = [];
var count = colors.push('blue','red');
// count : 2

count = colors.push('green');
//count : 3

var item = colors.pop();
//item : green
//colors.length : 2
```


- 队列方法 （first-in-first-out）
 	- `shift()` 移除数组第一个项目并返回该项目，同时数组长度-1
 	- `unshift()` 在数组前端添加任一个项目，并返回新数组的长度
 	- `shift` + `push` 模拟正向队列操作
 	- `unshift` + `pop` 模拟反向队列操作

```js
 var colors = [];
 var count = colors.push('red','blue');
 //count : 2
 count = colors.push('black');
 //count : 3
 var item = colors.shift();
 //item : 'red'
 // colors.length: 2
```


- 重排序方法
	- `reverse()` 反转项目
	- `sort()`
		- 默认情况下升序排列 （比较字符串）
	- `reverse()` 和 `sort()` 返回的都是经过排序的数组
	- 对于数值类型或其他`valueOf()`方法返回数值类型的对象类型，可以简写compare为 `return val2 - val1`

```js
function compare(val1,val2){
	if(var1 < val2){
		return -1;
	}else if(val1 > val2){
		return 1;
	}else{
		return 0;
	}
}
var arr = [1,2,4,7,3];
arr.sort(compare);
//arr : [1,2,3,4,7]
```


- 操作方法
	- `concat()` 基于当前数组所有项创建一个新的数组
		- 没有参数：复制当前数组并返回副本
		- 参数是一个或多个数组：参数中数组的每一项都添加到结果数组中
		- 参数是值：添加到数组末尾
	- `slice()` 基于当前数组中的一个或多个项创建一个新的数组
		- 一个参数：返回从该参数指定的位置开始到末尾的所有项
		- 两个参数：返回**起始**和**结束**位置之间的项 （不包括结束位置）
		- 如果参数为负数：用数组长度加上该数来确定相应的位置，对长度为5的数组 `slice(-2,-1)` = `slice(3,4)`
	- `splice()` 向数组的中部插入项目，始终返回新数组
		- 删除：需要两个参数，要删除的第一项的位置和要删除的数量
		- 插入：需要三个参数，起始位置、要删除的数量、要插入的项目
		- 替换：需三个参数，起始位置、要删除的数量、要插入的任意数量的项，向指定位置插入任意数量的项目，同时删除任意数量的项目


```js
/**concat**/
var arr = [1,2,3];
var arr2 = arr.concat(4,[5,6]);
//arr : [1,2,3]
//arr2 : [1,2,3,4,5,6]

/**slice**/
var arr = [1,2,3,4,5,6,7,8];
var arr2 = arr.slice(1);
var arr3 = arr.slice(1,4);
//arr2 : [2,3,4,5,6,7,8]
//arr3 : [2,3,4] 不包含结束位置

/**splice**/
var arr = [1,2,3,4,5,6,7,8];
var removed = arr.splice(0,1);
//arr : [2,3,4,5,6,7,8]
//removed : [1]

var arr = [1,2,3,4,5,6,7,8];
var removed = arr.splice(1,0,'a','b');
//arr : [1,'a','b',2,3,4,5,6,7,8];
//removed : []

var arr = [1,2,3,4,5,6,7,8];
var removed = arr.splice(1,1,'a','b');
//arr : [1, "a", "b", 3, 4, 5, 6, 7, 8]
//removed : [2]
```


- 位置方法
	- `indexOf()` 和 `lastIndexOf()` 两个方法都接收两个参数：要查找的项和表示查找起点位置的索引（可选）
	- 两个方法都返回要查找项目的索引，没有找到返回 `-1`
	- 使用全等操作


```js
var arr = [1,2,3,4,5,4,3,2,1]
arr.indexOf(4) //3
arr.lastIndexOf(4) // 5
arr.indexOf(4,4) //5
arr.lastIndexOf(4,4) //3

var person = {name:'shabi'};
var people = [{name:'shabi'}];
var morePeople = [person];
people.indexOf(person) // -1
morePeople.indexOf(person) //0
```


- 迭代方法，接收三个参数：数组项的值、该项在数组中的位置、数组对象本身
	- `every()` 对数组中的每一项运行函数，如果对每一项都返回true，则返回true
	- `filter()` 对数组中的每一项运行函数，返回该函数会返回true的项组成的数组
	- `forEach()` 对数组中的每一项运行函数，没有返回值，与`for`相同
	- `map()` 对数组中的每一项运行函数，返回每次函数调用的结果组成的数组
	- `some()` 对数组中的每一项运行函数，如果该函数对任一项返回true，则返回true

```js
var arr = [1,2,3,4,5,4,3,2,1]
var everyResult = arr.every(function(item,index,array){
	return (item > 2);
})
//everyResult : false
var someResult = arr.some(function(item,index,array){
	return (item > 2);
})
//someResult : true
var filterResult = arr.filter(function(item,index,array){
	return (item > 2);
})
//filterResult : [3,4,5,4,3]
var mapResult = arr.map(function(item,index,array){
	return (item > 2);
})
//mapResult : [2,4,6,8,10,8,6,4,2]
```


- 归并方法
	- `reduce()` `reduceRight()` 都会迭代数组中所有的项，并返回最终的值
	- 接收两个参数：一个在每一项上调用的函数，作为归并基础的初始值（可选的）
	- 传给 `reduce()` `reduceRight()` 的函数接收四个参数：前一个值、当前值、项的索引、数组对象
	- 回调函数返回的任何值都会作为一个参数自动传给下一项

```js
var arr = [1,2,3,4,5];
var sum = arr.reduce(function(prev,cur,index,array){
	return prev + cur
})
//sum : 15
```


###Date类型
- 创建日期对象 `new Date()` 表示当前时间
- 根据特定日期和时间创建Date对象 `Date.parse()` ，接收一个表示日期的字符串，返回时间戳

```js
var someDate = new Date(Date.parse('2014.1.1,12:12'));
// Wed Jan 01 2014 12:12:00 GMT+0800 (CST)
```


- `Data.UTC()` 基于GMT时间，返回时间戳，参数分别为：年份（必须）、月份（必须，基于0）、月中的一天（1-31）、小时（0-23），分钟、秒、毫秒，天数默认1，其他默认0

```js
new Date(Date.UTC(2000,0)) //Sat Jan 01 2000 08:00:00 GMT+0800 (CST)
new Date(Date.UTC(2005,4,5,17,55,55)) //Fri May 06 2005 01:55:55 GMT+0800 (CST)
```


- `Date` 基于本地时间

```js
new Date(2000,0) //Sat Jan 01 2000 08:00:00 GMT+0800 (CST)
new Date(2005,4,5,17,55,55) //Fri May 06 2005 01:55:55 GMT+0800 (CST)
```


- `Date.now()` 返回当前时间戳

```js
var start = Date.now();
var stop = Date.now();
var result = stop - start;
```


- `Date` 的 `valueOf` 不返回字符串而返回时间戳
- `Date` 对象可以进行对比
- 格式化 `Date` 对象
	- `toDateString` 星期、月、日、年
	- `toTimeString` 小时、分、秒和**时区**
	- `toLocaleDateString`  `toLocaleTimeString` 特定于本地地区格式
	- `toUTCString` 完整的UTC日期，等同于 `toGMTString`
- 日期、时间组建方法

|方法|说明|
|---|---|
|getTime()	|返回表示日期的毫秒数；与valueOf()方法返回的值相同|
|setTime（毫秒）	|以毫秒数设置日期，会改变整个日期|
|getFullYear()	|取得4位数的年份（如2007而非仅07）|
|getUTCFullYear()	|返回UTC日期的4位数年份|
|setFullYear（年）	|设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）|
|setUTCFullYear（年）	|设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）|
|getMonth()	|返回日期中的月份，其中0表示一月，11表示十二月|
|getUTCMonth()	|返回UTC日期中的月份，其中0表示一月，11表示十二月|
|setMonth（月）	|设置日期的月份。传入的月份值必须大于0，超过11则增加年份|
|setUTCMonth（月）	|设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份|
|getDate()	|返回日期月份中的天数（1到31）|
|getUTCDate()	|返回UTC日期月份中的天数（1到31）|
|setDate（日）	|设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份|
|setUTCDate（日）	|设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份|
|getDay()	|返回日期中星期的星期几（其中0表示星期日，6表示星期六）|
|getUTCDay()	|返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六）|
|getHours()	|返回日期中的小时数（0到23）|
|getUTCHours()	|返回UTC日期中的小时数（0到23）|
|setHours（时）	|设置日期中的小时数。传入的值超过了23则增加月份中的天数|
|setUTCHours（时）	|设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数|
|getMinutes()	|返回日期中的分钟数（0到59）|
|getUTCMinutes()	|返回UTC日期中的分钟数（0到59）|
|setMinutes（分）|	设置日期中的分钟数。传入的值超过59则增加小时数|
|setUTCMinutes（分）	|设置UTC日期中的分钟数。传入的值超过59则增加小时数|
|getSeconds()	|返回日期中的秒数（0到59）|
|getUTCSeconds()	|返回UTC日期中的秒数（0到59）|
|getUTCSeconds()	|返回UTC日期中的秒数（0到59）|
|setSeconds（秒）	|设置日期中的秒数。传入的值超过了59会增加分钟数|
|setUTCSeconds（秒）	|设置UTC日期中的秒数。传入的值超过了59会增加分钟数|
|getMilliseconds()	|返回日期中的毫秒数|
|getUTCMilliseconds()	|返回UTC日期中的毫秒数|
|setMilliseconds（毫秒）	|设置日期中的毫秒数|
|setUTCMilliseconds（毫秒）	|设置UTC日期中的毫秒数|
|getTimezoneOffset()	|返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化|

###RegExp类型

- 创建正则表达式

```js
var expression = / pattern / flags;
表达式 = / 模式 / 标志
```


- 模式部分可以是任意正则表达式，标志用来表明正则表达式的行为
	- `g` 全局模式，『模式』被用于所有字符串，忽略代表发现第一个匹配时停止
	- `i` 忽略大小写
	- `m` 多行模式，达到文本末尾时继续查找下一行

```js
var pattern1 = /at/g; //匹配字符串中所有at
var pattern2 = /[bc]at/i; //匹配第一个'bat'.'cat'不区分大小写
var pattern3 = /.at/gi; //匹配所有以'at'结尾的3个字符组合，不区分大小写
```


- 所有**元字符**必须转意 `( [ { \ ^ $ | ) ? * + . ] }`
- RegExp构造函数只接收字符串参数，元字符需二次转意，不能把正则表达式字面量传递给RegExp构造函数
- RegExp实例属性 （无大用处）
	- `global` 布尔，是否设置了g标志
	- `ignoreCase` 布尔，是否设置了i标志
	- `lastIndex` 整数，开始搜索下一个匹配项的字符位置，从0开始
	- `multiline` 布尔，是否设置了m标志
	- `source` 正则表达式的字符串表示
- `exec()` 捕获**组**，接收一个参数：应用模式的字符串
	- 返回包含第一个匹配项信息的数组，返回的数组包含`index`和`input`
	- `index` 表示匹配项在字符串中的位置
	- `input` 表示正则表达式的字符串
	- 没有全局标志时，始终返回第一个匹配项信息
	- 有全局标志，每次都会继续查找新的匹配项

```js
var text = "mom and dad and baby";
var pattern = /mom( and dad( and baby)?)?/gi
var matches = pattern.exec(text);
matches.index //0
matches.input //mom and dad and baby
matches[0] //mom and dad and baby
matches[1] // and dad and baby
matches[2] // and baby
```


- `test()` 接收字符串为参数，匹配返回true

```js
var text = "000-00-0000";
var pattern = /\d{3}-\d{2}-\d{4}/;
pattern.test(text) // true
```


- 正则表达式的 `valueOf()` 返回正则表达式本身
- RegExp 构造函数的属性，适用于当前作用域中的所有正则表达式，并且基于最后一次正则操作而变化
- RegExp.$1 .$2 用于储存9个捕获组的的属性

|长属性名|短属性名（Opera不支持）|说　　明|
|------|-----|----|
|input	|$_	|最近一次要匹配的字符串|
|lastMatch	|$&|	最近一次的匹配项|
|lastParen	|$+|	最近一次匹配的捕获组|
|leftContext	|$、|	input字符串中lastMatch之前的文本|
|multiline	|$*|	布尔值，表示是否所有表达式都使用多行模式|
|rightContext	|$'|	Input字符串中lastMatch之后的文本|

###Function类型

- 函数实际是对象，每个函数都是Function类型的实例
- 函数名实际上是指向函数对象的指针，不会与函数绑定
- 一个函数可以有多个名字
- 不带 `()` 的函数名是访问函数指针，不是调用
- 创建相同函数名的函数会覆盖之前的引用

```js
function num(val1,val2){
	return val1 + val2;
};
sum(10,10) //20
var anotherSum = sum;
anotherSum(10,10) //20
sum = null;
anotherSum(10,10) //20
```


- 函数声明提升：解析器会将 `function num(){}` 提升至代码树的顶部， `var num = function(){}` 不会提升
- 函数名本身就是变量，可以传入其他函数，并执行第一个参数后的结果
- 函数内部包含 `this` 和 `arguments` 两个对象
- `arguments.callee` 指向拥有这个arguments对象的函数

```js
function factorial(num){
	return num * factorial(num - 1); //factorial的执行与函数名耦合
}
function factorial(num){
	return num * arguments.callee(num - 1); //消除耦合
}
```


- `this` 引用的是函数执行的环境对象

```js
window.color = 'red';
var o = {color:'blue'};
function getColor(){
	return this.color;
}
getColor() //red this引用全局作用域
o.getColor = getColor;
o.getColor() //blue this引用o

//函数名是包含指针的变量，getColor()和o.getColor()指向的仍是一个函数
```


- `caller` 保存调用当前函数的函数的引用

```js
function outer(){
	inner();
};

function inner(){
	alert (inner.caller);
};

outer(); //outer的代码

/**松耦合**/
function outer(){
	inner();
}
function inner(){
	alert (arguments.callee.caller);
}
```


- `functionName.length` 表示函数希望接收到的命名参数的个数
- `call()` `apply()` 在特定的作用域中调用函数，设置函数体内的 `this`，**好处是对象不需要与方法有耦合关系**
- `apply()` 接收数组参数，`call()` 接收直接传递
- `bind()` 方法创建一个函数的实例，`this` 绑定到传给 `bind()` 的值

```js
function sum(val1,val2){
	return val1 + val2;
}

function callSum1(val1,val2){
	return sum.apply(this,arguments); //或 sum.apply(this,[val1,val2]);
	//sum.call(this,val1,val2)
}

window.color = 'red';
var o = {color:'blue'};
function getColor(){
	return this.color;
}

getColor(); //red
getColor.call(this); //red
getColor.call(window); //red
getColor.call(o); //blue
var anotherGetColor = getColor.bind(o);
anotherGetColor(); //blue
```


- 基本类型值不是对象，但是有「方法」

```js
var s1 = 'str';
var s2 = s1.substring(1);

/**等同于**/
var s1 = new String('str');
var s2 = s1.substring(1);
s1 = null;
```


- 基本类型值只存在于一行代码执行的瞬间，然后销毁

```js
var s1 = 'str';
s1.color = 'red';
// s1.color : undefined
```


- `typeof` 基本类型实例返回 `object` ，基本类型包装对象会被转换为布尔 `true`
- `Object` 构造函数会根据传入的值返回相应的基本包装类型的实例

```js
var obj = new Object('str');
obj instanceof String //true

var number = Number(25);
typeof number // number

var obj2 = new Number(25);
typeof obj2 // object
```


- typeof操作符对基本类型返回"boolean"，而对引用类型返回"object"
- 由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false
- `toFixed()` 方法会按照指定的小数位返回 `number` 类型的数值的字符串表示
- `toExponential()` 方法返回 `number` 类型的质数表示法
- `String` 类型的每个实例都有一个 `length` 属性，表示包含字符数量
- 字符方法
	 - `charAt()` 返回给定位置的的字符
	 - `charCodeAt()` 返回给定位置的的字符编码
- 字符串操作方法，返回一个子字符串，第一个参数指定子字符串的开始位置，第二个参数表示子字符串在哪里结束
	- `slice()` 第二个参数指定的是子字符串最后一个字符后面的位置，传入的负值参数与字符串长度相加
	- `substring()` 第二个参数指定的是子字符串最后一个字符后面的位置，传入的负值参数都转换为0
	- `substr` 第二个参数指定的返回的字符的个数，第一个负值参数与字符串长度相加，第二个负值参数转换为0

```js
var str = 'hello world';
str.slice(3); // lo world
str.substring(3); // lo world
str.substr(3); // lo world
str.slice(3,7); // lo w
str.substring(3,7); // lo w
str.substr(3,7); // lo worl

str.slice(-3); // rld
str.substring(-3); // hello world
str.substr(-3); // rld
str.slice(3,-4); // lo w
str.substring(3,-4); // hel
str.substr(3,-4); // "" 空字符串
```


- 字符串位置方法，`indexOf()` `lastIndexOf()`，如果没有找到该子字符串，返回-1，第二个参数表示从字符串中哪个位置开始搜索

```js
var str = 'hello world';
str.indexOf('o'); //4
str.lastIndexOf('o'); //7
str.indeOf('o',6) //7
str.lastIndexOf('o',6) //4

var str1 = 'Material icons are beautifully crafted, delightful, and easy to use in your web, Android, and iOS projects.'
var positions = [];
var pos = str1.indexOf('e');
while (pos > -1){
	positions.push(pos);
	pos = str1.indexOf('e', pos + 1);
}
positions // [3, 17, 20, 36, 41, 56, 66, 77, 102]
```


- `trim()` 返回字符串删除前置后缀空格的字符串副本
- `toLowerCase()` `toUpperCase()` 转换字符串大小写
- 字符串的 `match()` 方法与RegExp的 `exec()` 方法一致，接收一个参数：正则表达式或RegExp对象

```js
var str = 'cat, bat, sat, fat';
var pattern = /.at/;
var matches = str.match(pattern);
matches.index // 0
matches[0] // cat
pattern.lastIndex // 0
```


- `search()` 方法返回字符串中第一个匹配项的索引，如果没有匹配项，返回-1

```js
var str = 'cat, bat, sat, fat';
var pos = str.search(/at/);
pos // 1
```


- `replace()` 方法接收两个参数：RegExp对象或一个字符串（字符串不会被转换为正则表达式）、字符串或一个函数。如果第一个参数是字符串，则只替换第一个子字符串，替换所有子字符串需要使用正则表达式并使用全局`g`标志

```js
var str = 'cat, bat, sat, fat';
var result = str.replace('at','ond');
result // cond, bat, sat, fat

var result2 = str.replace(/at/g, 'ond');
result2 // cond, bond, sond, fond
```


- `replace()` 如果第二个参数是字符串，可以使用一些特殊字符序列，将正则表达式操作的到的值插入到结果字符串中

| 字符序列 | 替换文本 |
|----|----|
|$$|$|
|$&	|匹配整个模式的子字符串。与RegExp.lastMatch的值相同|
|$'	|匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同|
|$、	|匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同|
|$n	|匹配第n捕获组的子字符串，其中n等于0~9。例如，$1是匹配第一个捕获组的子字符串，$2是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串|
|$nn	|匹配第nn个捕获组的子字符串，其中nn等于01~99。例如，$01是匹配第一个捕获组的子字符串，$02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串|


```js
var str = 'cat, bat, sat, fat';
var result = str.replace(/(.at)/g,'word ($1)');
result // word(cat), word(bat), word(sat), word(fat)
```


- `replace()` 如果第二个参数是函数
	- 在只有一个匹配项时，会向函数传递3和参数：模式匹配的项、模式匹配项在字符串中的位置、原始的字符串
	- 多个匹配项传递参数依次是：模式的匹配项、第一个匹配项、第二个匹配项···，最后两个参数是模式匹配项在字符串中的位置、原始的字符串
	- 函数返回一个字符串

```js
function htmlEscape(text){
	return text.replace(/[<>"&"]/g, function(match, pos, originalText){
		switch(match){
			case "<":
					return "&lt;";
				case ">":
					return "&gt;";
				case "&":
					return "&amp;";
				case "\"":
					return "&quot;";
		}
	})
}
var html = "<div class='test'>hello</div>";
htmlEscape(html); // "&lt;div class='test'&gt;hello&lt;/div&gt;"
```

- `split()` 方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。
	- 分隔符可以是一个字符串，也可以是一个RegExp对象
	- 第二个可选参数，指定生成数组的长度

```js
var text = 'red,blue,green,yellow';
text.split(','); // ["red", "blue", "green", "yellow"]
text.split(',',2); // ["red", "blue"]
text.split(/[^\.]+/); // ["", ""]
```

- `localeCompare()` 比较字符串
- `fromCharCode()` 接收一个或多个字符编码，转换为字符串

###单体内置对象

> 由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。

#### Global对象

- `isNaN()` `isFinite()` `parseInt()` `parseFloat()` 都是全局对象的方法
- `encodeURI()` `encodeURIComponent()` 对URI进行编码
	- `encodeURI()` 主要用于整个URI，不会对本身属于URL的特殊字符（冒号、正斜杠、问好、#）进行编码
	- `encodeURIComponent()` URI中的某一段，对任何非标准字符码进行编码

> 一般来说，使用encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码

- `deCodeURI()` `deCodeURIComponent()` 解码URI
- `eval()` 方法将传入的参数当做实际的ES语句来解析，然后把执行结果插入到原位置，被执行的代码具有与该执行性环境相同的作用域链。
- `eval()` 中创建的任何函数或变量都不会被提升

> 在使用eval()时必须极为谨慎，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）。

|属性|说明|属性|说明|
|---|---|---|---|
|undefined|特殊值undefined|Date|构造函数Date|
|NaN|特殊值NaN|RegExp|构造函数RegExp|
|Infinity|特殊值Infinity|Error|构造函数Error|
|Object|构造函数Object|EvalError|构造函数EvalError|
|Array|构造函数Array|RangeError|构造函数RangeError|
|Function|构造函数Function|ReferenceError|构造函数ReferenceError|
|Boolean|构造函数Boolean|SyntaxError|构造函数SyntaxError|
|String|构造函数String|TypeError|构造函数TypeError|
|Number|构造函数Number|URIError|构造函数URIError|

#### window对象

浏览器将全局对象对胃window对象的一部分加以实现的

```js
var global = function(){
	return this;
}();
//一个立即调用的函数表达式，返回this的值
//在没有给函数明确指定this值的情况下，无论是通过将函数添加为对象的方法，还是通过调用call()或apply()
//this值等于Global对象。这样通过简单地返回this来取得Global对象，在任何执行环境下都是可行的
```


#### Math对象

|方法|描述|方法|描述|
|--|--|--|--|
|abs(x)|	返回数的绝对值|**max(x,y)**|	返回 x 和 y 中的最高值|
|acos(x)|	返回数的反余弦值|**min(x,y)**|	返回 x 和 y 中的最低值|
|asin(x)|	返回数的反正弦值|pow(x,y)|	返回 x 的 y 次幂|
|atan(x)|	以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值|**random()**|	返回 0 ~ 1 之间的随机数|
|atan2(y,x)|	返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）|**round(x)**|	把数四舍五入为最接近的整数|
|**ceil(x)**|	对数进行上舍入|sin(x)|	返回数的正弦|
|cos(x)|	返回数的余弦|sqrt(x)|	返回数的平方根|
|exp(x)|	返回 e 的指数|tan(x)|	返回角的正切|
|**floor(x)**|	对数进行下舍入|toSource()|	返回该对象的源代码|
|log(x)|	返回数的自然对数（底为e）|valueOf()|	返回 Math 对象的原始值|