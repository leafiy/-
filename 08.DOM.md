##DOM

> IE中的所有DOM对象都是以COM对象的形式实现的。这意味着IE中的DOM对象与原生JavaScript对象的行为或活动特点并不一致

###节点层次

- HTML元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点类型，这些类型都继承自一个基类型

####NODE类型

- DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现
- Node接口在JavaScript中是作为Node类型实现的，除了IE之外，在其他所有浏览器中都可以访问到这个类型
- JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。
- 每个节点都有一个nodeType属性，用于表明节点的类型
	- Node.ELEMENT_NODE（1）
	- Node.ATTRIBUTE_NODE（2）
	- Node.TEXT_NODE（3）
	- Node.CDATA_SECTION_NODE（4）
	- Node.ENTITY_REFERENCE_NODE（5）
	- Node.ENTITY_NODE（6）
	- Node.PROCESSING_INSTRUCTION_NODE（7）
	- Node.COMMENT_NODE（8）
	- Node.DOCUMENT_NODE（9）
	- Node.DOCUMENT_TYPE_NODE（10）
	- Node.DOCUMENT_FRAGMENT_NODE（11）
	- Node.NOTATION_NODE（12）

```js
// 是否为一个元素
someNode.nodeType == 1; // ture 为元素
someNode.nodeName; // 元素标签名
someNode.nodeValue; // null
```

- 每个节点都有一个 `childNodes` 属性，其中保存着一个 `NodeList` 对象。`NodeList` 是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点 ()
- `NodeList` 有 `length` 属性，但并不是Array实例
- `NodeList` 通过 `DOM` 结构动态执行查询结果，`DOM` 结构变化自动反映在 `NodeList` 对象中
- 每个节点都有一个 `parentNode` 属性，该属性指向文档树中的父节点
- 包含在 `childNodes` 列表中的所有节点都具有相同的父节点，因此它们的parentNode属性都指向同一个节点
- 包含在 `childNodes` 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的 `previousSibling` 和 `nextSibling` 属性，可以访问同一列表中的其他节点
- 列表中第一个节点的 `previousSibling` 属性值为 `null`，而列表中最后一个节点的 `nextSibling` 属性的值同样也为 `null`
- 父节点的 `firstChild` 和 `lastChild` 属性分别指向其 `childNodes` 列表中的第一个和最后一个节点
- `someNode.firstChild` 的值始终等于 `someNode.childNodes[0]` `someNode.lastChild` 的值始终等于 `someNode.childNodes[someNode.childNodes.length-1]`
- 在只有一个子节点的情况下，`firstChild` 和 `lastChild` 指向同一个节点。如果没有子节点，`firstChild` 和 `lastChild` 的值均为 `null`
- `hasChildNode()` 在节点包含一或多个子节点的情况下返回true
- 所有节点都有的最后一个属性是 `ownerDocument`，该属性指向表示整个文档的文档节点

#####操作节点

- `appendChild()` 用于向 `childNodes` 列表末尾添加一个节点，添加节点后， `childNodes` 的新增节点、父节点、以前的最后一个子节点的关系指针都会更新
- `appendChild()` 返回新增的节点

```js
var returnedNode = someNode.appendChild(newNode);
returnedNode == newNode; // true
someNode.lastChild == newNode; // true
```

- 如果传入到 `appendChild()` 中的节点已经是文档的一部分了，那就是将该节点从原来的位置转移到新位置了， `DOM` 节点不能同时出现在多个位置上

```js
// someNode 有多个子节点
var returnedNode = someNode.appendChild(someNode.firstChild);
returnedNode == someNode.firstChild; // false
returnedNode == someNode.lastChild; // true
```

- 使用 `insertBefore()` 方法把节点放在 `childNodes` 列表中的某个位置，接收两个参数：要插入的节点、作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点，同时被方法返回
- 如果 `insertBefore()` 的参照节点为 `null` ，则与 `appendChild()` 方法相同

```js
var returnedNode = someNode.insertBefore(newNode, null);
newNode == someNode.lastChild; // true

var returnedNode = someNode.insertBefore(newNode, someNode.firstChild);
returendNode == newNode; // true
returnedNode == someNode.firstChild; // true

var returnedNode = someNode.insertBefore(newNode, someNode.lastChild);
returnedNode == someNode.childNodes[someNode.childNodes.length-2]; // true
```

- `replaceChild()` 方法替换节点，接收两个参数：要插入的节点、要替换的节点。要插入的节点占用被替换的节点的位置
- `removeChild()` 方法移除节点，接收一个参数：要移除的节点。返回被移除的节点
- 被替换或移除的节点仍为文档所有，只是在文档中没有自己的位置
- `cloneNode()` 用于创建调用这个方法的节点的一个完全相同的副本，接收布尔参数
	- true 参数为深复制，包括节点及整个子节点树
	- false 参数为浅复制，只赋值节点本身
	- 复制后返回的节点副本属于文档所有，并没有父节点
	- 不会赋值节点中的js属性（事件处理等，**IE使用时复制之前移除时间处理程序**）

####Document类型

- `document` 对象是 `HTMLDocument` 的一个实例，表示整个 HTML 页面，而且是 `window` 对象的一个属性，可作为全局对象来访问
	- nodeType的值为9
	- nodeName的值为"#document"
	- nodeValue的值为null
	- parentNode的值为null
	- ownerDocument的值为null
	- 其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment
- `document.documentElement` 属性指向HTML页面中的html元素
- `document.body` 直接指向body元素
- `document.title` 可以读取或修改当前页面的标题，但不会改变 `<title>` 元素

#####查找元素 （重点）

- `document.getElementById()` 返回id对应的元素，如没有返回null
- `document.getElementsByTagName()` 返回 `HTMLCollection` 对象
- `HTMLCollection` 对象的 `namedItem()` 方法通过元素的的 `name` 特性取得集合中的项
- `document.getElementsByName()` 返回给定 `name` 的所有元素（只有`HTMLDocument`类型才有）

```js
var imgs = document.getElementsByTagName('img');
imgs.length // img数量
imgs[0].src // 第一个img的src特性
imgs.item(0).src // 第一个img的src特性

<img scr="src.jpg" name="named">
var img = imgs.namedItem('named');
var img = imgs['named'];

document.getElementsByTagName('*'); // 取得页面中的所有元素（IE中包含注释元素）
```

|特殊元素集合|说明|
|---|---|
|document.anchors|包含文档中所有带name特性的`<a>`元素|
|document.applets|包含文档中所有的`<applet>`元素，因为不再推荐使用`<applet>`|元素，所以这个集合已经不建议使用了|
|document.forms|包含文档中所有的`<form>`元素，与`document.getElementsByTagName（"form"）`得到的结果相同|
|document.images|包含文档中所有的`<img>`元素，与`document.getElementsByTagName（"img"）`得到的结果相同|
|document.links|包含文档中所有带href特性的`<a>`元素|

- `document.write()` 原样写入输出流中的文本
- `document.writeln()` 在末尾添加换行符 `\n`

> 严格型XHTML文档不支持文档写入，对于那些按照application/xml+xhtml内容类型提供的页面，这两个方法也同样无效

####Element类型

- `element` 节点包括以下特性
	- nodeType的值为1
	- nodeName的值为元素的标签名
	- nodeValue的值为null
	- parentNode可能是Document或Element
	- 其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EntityReference
- 访问元素的标签名可以使用 `nodeName` 和 `tagName` (使用时均转换为小写使用)
- 所有HTML元素都是由 `HTMLElement` 类型（或其子类型）表示
	- id，元素在文档中的唯一标识符
	- title，有关元素的附加说明信息，一般通过工具提示条显示出来
	- lang，元素内容的语言代码，很少使用
	- dir，语言的方向，值为"ltr"（left-to-right，从左至右）或"rtl"（right-to-left，从右至左），也很少使用
	- className，与元素的class特性对应，即为元素指定的CSS类
	- *以上属性都可以用来取得或修改*
- 操作特性的 `DOM` 方法，**特性名称不区分大小写**
	- `getAttribute()` 特性名称与实际特性名相同，但 `class` 用 `className`，`style` 特性返回CSS文本，事件处理程序返回代码字符串
	- `setAttribute()` 接收名称和值，若已存在则替换
	- `removeAttribute()`
- `attributes` 属性，动态集合，元素的每一个特性都由一个 `Attr` 节点表示，每个节点都保存在 `NamedNodeMap` 对象中（不常用）
- `document.createElement()` 方法创建元素，只接收标签名不区分大小写
	- 元素被添加到文档树中后，会立刻成仙，对元素所做的改变也会实时反映

```js
var div = document.createElement('div');
div.id = 'id';
div.className = 'class-1';
div.innerText = 'aaa';
document.body.appendChild(div);

var div2 = document.createElement('<div id=\'id2\'></div>')
```

- 使用 `childNodes` 遍历子节点时，注意空白文本节点

```js
for(var i = 0;i < el.childNodes.length;i++){
	if(el.childNodes[i].nodeType == 1){
		// do something
		// 子节点是元素节点才执行
	}
}
```

- 元素也支持 `getElementsByTagName()` 方法，在元素调用此方法时，搜索起点为当前元素

####Text类型

- 包含可以照字面解释的纯文本内容，可以包含转义后的HTML字符，不能包含HTML代码
	- nodeType的值为3
	- nodeName的值为"#text"
	- nodeValue的值为节点所包含的文本
	- parentNode是一个Element
	- 不支持（没有）子节点
- 每个可以包含内容的元素最多只有一个文本节点，而且必须确实有内容存在

```html
<div></div> <!--没有内容，没有文本节点-->
<div> </div> <!--有空格，有一个文本节点-->
<div>hello world</div> <!--有内容，有一个文本节点-->
```

- `document.createTextNode()` 创建文本节点

```js
var textNode = document.createTextNode('<strong>hello</strong> world');
```

- 如果两个文本节点是相邻的，这两个文本节点会连接起来且中间没有空格
- `normalize()` 方法可以合并相邻的文本节点

####DocumentFragment类型

- 文档片段，不会占用资源，不能直接添加到文档做，当做「仓库」使用，可以再文档片段中保存将来可能会添加到文档中的文档节点，文档片段继承了所有NODE的方法
	- nodeType的值为11；
	- nodeName的值为"#document - fragment"；
	- nodeValue的值为null；
	- parentNode的值为null；
	- 子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection或EntityReference



###DOM操作技术

- 动态加载的script文件能立即运行

```js
// 动态加载脚本
function loadScript(url){
	var s = doucment.createElement('script');
	s.type = 'text/javascript';
	s.src = url;
	document.body.appendChild(s);
}

// 动态加载css
function loadStyle(url){
	var s = document.createElement('link');
	s.rel = 'stylesheet';
	s.type = 'text/css';
	s.href = url;
	var head = document.getElementByTagName('head')[0];
	head.appendChild(s);
}
```

####使用NodeList

- NodeList对象都是在访问DOM文档时实时运行的查询，应该尽量减少访问NodeList的次数，将从NodeList中取得的值缓存起来