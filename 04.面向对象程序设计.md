##面向对象程序设计

- 数据属性，包含一个数据值的位置，在这个位置可以读取和写入值
	- `[[Configurable]]` 能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，默认值为 true
	- `[[Enumerable]]` 能否通过 `for-in` 返回属性，默认值为 true
	- `[[Writable]]` 能否修改属性值，默认值为 true
	- `[[Value]]` 包含这个属性的数据值，读取属性时从这个位置读，写入属性值，把新值保存在这个位置，默认为 undefined

- `Object.defineProperty()` 接收三个参数：属性所在的对象、属性的名字和一个描述符对象。描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对应的特性值


```js
var person = {};
Object.defineProperty(person, 'name', {
	writable: false,
	value: 'shabi'
})
person.name // shabi
person.name = 'dashabi';
person.name //shabi

var person = {};
Object.defineProperty(person, 'name', {
	configurable: false,
	value: 'shabi'
})
person.name // shabi
person.name = 'dashabi';
person.name //shabi

```


- 一旦把属性定义为不可配置的，就不能再把它变回可配置了。再调用 `Object.defineProperty()` 方法修改除writable之外的特性，都会导致错误

```js
var person = {};
Object.defineProperty(person, 'name', {
	configurable: false,
	value: 'shabi'
})

Object.defineProperty(person, 'name', {
	configurable: true,
	value: 'shabi'
})
// 会出错
```


- 访问器属性，不包含数据值，包含 `getter` 和 `setter` 函数（非必须），访问器属性不能直接定义
	- `[[Configurable]]` 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，默认值为true
	- `[[Enumerable]]` 表示能否通过for-in循环返回属性。对直接在对象上定义的属性，默认值为true
	- `[[get]]` 在读取属性时调用，默认undefined
	- `[[set]]` 在写入属性时调用，默认undefined

```js
var book = {
	_year: 2004,
	edition: 1
}
Object.defineProperty(book, 'year', {
	get:function(){
		return this._year
	},
	set:function(newValue){
		if(newValue > 2004){
			this._year = newValue;
			this.edition += newValue - 2004
		}
	}
})
book.year = 2016;
book.editon // 13
```

- 只指定 `getter` 函数意味着属性不能写
- 不支持 `Object.defineProperty()` 的浏览器中不能修改 `[[Configurable]]` `[[Enumerable]]`
- `Object.defineProperties()` 定义多个属性，接收两个参数：要添加和修改的属性的对象、与第一个对象中要添加或修改的属性对应的对象

```js
var book = {}
Object.defineProperties(book, {
	_year:{
		value:2004,
		writable: true
	},
	year:{
		get:function(){
			return this._year;
		},
		set:function(newValue){
			this._year = newValue
		}
	}
})
```

- `Object.getOwnPropertyDescriptor()` 读取属性特性，返回对象

```js
var descriptor = Object.getOwnPropertyDescriptor(book, '_year');
descriptor.value // 2004
descriptor.configurable // false
descriptor.get // undefined
```


#### 创建对象

- 使用对象字面量创建对象的缺点：使用同一个接口创建很多对象，会产生大量的重复代码

#####工厂模式

> 用函数来封装以特定接口创建对象的细节

- 缺点：无法知道一个对象的类型


```js
function createPerson(name, age){
	var o = new Object();
	o.name = name;
	o.age = age;
	o.sayName = function(){
		alert (this.name)
	}
	return o;
}
var person1 = createPerson('shabi',29);
```


####构造函数模式

> 以这种方式定义的构造函数是定义在Global对象中


```js
function Person(name, age){
	o.name = name;
	o.age = age;
	o.sayName = function(){
		alert (this.name)
	}
}
var person1 = new Person('shabi',29);
person.constructor == Person // true
person instanceof Person // true
person instanceof Object // true
//没有显式的创建对象，没有将属性和方法赋给this，没有return语句
```

- 构造函数应以大写字母开头
- `new` 操作符调用构造函数，实际会经历下面4个步骤
	1. 创建一个新的对象
	2. 将构造函数的作用域赋给新的对象 （this指向新的对象）
	3. 执行构造函数中的代码
	4. 返回新对象
- 新对象的 `constructor` 指向构造函数
	- `constructor` 用来标识对象类型
	- 自定义构造函数意味着可以将它的实例标识为一种特定的类型

#####将构造函数当做函数

- 构造函数与其他函数区别在于调用的方式不同
- 任何函数通过 `new` 调用，都可以作为构造函数


```js
function Person(name, age){
	o.name = name;
	o.age = age;
	o.sayName = function(){
		alert (this.name)
	}
}
var person = new Person('shabi',30);
person.sayName(); // shabi

Person('dashabi',20);
window.sayName(); // shabi 添加到window全局对象中
// 当在全局作用域中调用一个函数，this总是指向Global对象

var o = new Object();
Person.call(o,'2shabi',20);
o.sayName(); // 2shabi 在另一个对象的作用域中调用
```


#####构造函数的缺点

- 每个方法都要在每个实例上重新创建一边，每定义一个函数，也就是实例化了一个对象，每一个都不是同一个 `Function` 的实例

#### 原型模式

> 每个函数都有一个原型 prototype 属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特性类型的所有实例共享的属性和方法

- `prototype` 就是通过调用构造函数而创建的那个对象实例的原型对象
- 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法，不必在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象中
- **与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的**


```js
function Person(){
}
Person.prototype.name = 'shabi';
Person.prototype.age = 30;
Person.prototype.sayName = function(){
	alert (this.name);
};
var person = new Person();
person.sayName(); // shabi

//将sayName()方法和所有属性直接添加到了Person的prototype属性中，构造函数变成了空函数。
//即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。
//所有实例访问的都是同一句属性和一个sayName函数
```


#####理解原型对象

> 只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针

- 创建了自定义构造函数之后，其原型对象默认只会取得 `constructor` 属性，其他方法都是从 `Object` 中继承来的
- 当调用了构造函数创建一个实例之后，该实例将的内部包含一个指针 `[[Prototype]]`，指向构造函数的原型对象
- `[[Prototype]]` 对脚本不可见，每个对象都支持一个 `__proto__`
- 原型对象的连接**只存在于实例与构造函数的原型之间**，不是存在于实例与构造函数直接
- 通过 `isPrototypeOf()` 方法确定对象直接是否存在原型关系
- 通过 `Object.getPrototypeOf()` 获取对象原型


```js
Person.prototype.isPrototypeOf(person) // true
Object.getPrototypeOf(person) == Perons.prototype; // true
Object.getPrototypeOf(person).name // shabi
```

- 当代码读取对象属性时，先搜索对象实例本身开始，如果找到则返回该属性的值，如果没找到则继续搜索指针指向的原型对象
- 原型最初只包含 `constructor` 属性，而该属性是共享的，可通过对象实例访问
- 实例与原型重名的属性，会屏蔽原型中的属性（不能通过实例重写原型中的值）,即使将属性设为null，也不会恢复原型链接
- 使用 `delete` 可以完全删除实例属性，从而访问原型中的属性
- 使用 `hasOwnProperty()` 方法检测一个属性是存在于实例还是原型中

```js
person.hasOwnPerperty('name'); // false 属性来自原型
person.job = 'coder';
person.hasOwnProperty('job'); // true 属性来自实例
```

- 使用 `Object.getOwnPerpertyDescriptor()` 获取原型的属性描述符

#####原型与 `in` 操作符

- `in` 操作符单独使用时，`in` 会在通过对象能够访问给定属性时返回true
- 可通过 `in` 和 `hasOwnProperty()` 确定属性到底是存在于对象中还是原型中

```js
function hasPrototypeProperty(object, name){
	return !object.hasOwnProperty(name) && !(name in object);
}
function Person(){};
Person.prototype.name = 'shabi';
var person = new Person();
hasPrototypeProperty(person,'name'); // true
person.name = 'dashabi';
hasPrototypeProperty(perosn,'name'); //false
//当在实例中重写name属性后，该属性就存在于实例中了，因此hasPrototypeProperty()返回false。
//即使原型中仍然有name属性，但由于现在实例中也有了这个属性，因此原型中的name属性就用不到了
```

- 使用 `Object.keys()` 取得对象上所有可枚举的**实例属性**，返回字符串数组
- 使用 `Object.getOwnPropertyNames()` 获得实例对象上所有属性

#####更简单的原型语法

```js
function Person(){};
Person.prototype = {
	name : 'shabi',
	age : 30
}
// 这种创建方式使 constructor 属性不再指向Person了
var person = new Person();
person.constructor == Person; //false

Person.prototype = {
	name : 'shabi',
	age : 30,
	constructor: Person
}
// 会导致 constructor 变成可枚举

/**重设构造函数**/
Object.defineProperty(Person.prototype, 'constructor', {
	enumerable: false,
	value: Person
})
```


#####原型的动态性

- 对原型对象所做的任何修改，都能够立即从实例上反应出来


```js
var person = new Person();
Person.prototype.sayHi = function(){
	alert ('hi')
}
person.sayHi(); // hi
```


> 原型修改为另一个对象会切断构造函数与最初原型之间的联系


```js
var person = new Person();
Person.prototype ={
	sayHi:function(){
		alert ('hi')
	}
}
person.sayHi(); // 错误
```


#####原生对象的原型

- 通过原生对象的原型，不仅可以取得所有默认方法的引用，还可以定义新的方法

```js
String.prototype.startsWith = function(text){
	return this.indexOf(text) == 0;
}
var str = 'hello world';
str.startsWith('hello'); // true
```


> 不推荐在产品化的程序中修改原生对象的原型。如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。而且，这样做也可能会意外地重写原生方法


#####原型对象的问题

- 对于包含引用类型值的属性，会修改原型属性，影响其他实例的引用


```js
function Person(){};
Person.prototype = {
	constructor: Person,
	friends:['a','b']
}
var person1 = new Person();
var person2 = new Person();
person1.friends.push('shabi');

person1.friends // a,b,shabi
person2.friends // a,b,shabi
person1.friends === person2.friends // true
```

**实例需要有属于自己的全部属性，所以不要单独使用原型模式**

####组合使用构造函数模式和原型模式

> 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。每个实例都会有自己的一份实例属性副本，但同时又共享着对方的方法的引用


```js
functon Person(name,age,job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.friends = ['a','b'];
}
Person.prototype = {
	constructor: Person,
	sayName: function(){
		alert (this.name);
	}
}
var person1 = new Person('shabi','30','coder');
var person2 = new Person('dashabi','20','designer');
person1.friends.push('sha2bi');

person1.friends //a,b,sha2bi
person2.friends //a, b
```


**推荐使用的创建自定义类型的方法**

####动态原型模式

- 把所有信息都封装在构造函数中，通过在构造函数中初始化原型，保存了构造函数和原型的优点


```js
function Person(name,age){
	this.name = name;
	this.age = age;
	if(typeof this.sayName != 'function'){ // 只有在sayName不存在的情况下才会添加到原型中
		Person.prototype.sayName = function(){
			alert (this.name);
		}
	}
}
var perosn = new Person('shabi','30');
person.sayName(); // shabi
```

> 原型已经完成初始化，不需要再做什么修改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可以说非常完美。其中，if语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆if语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用instanceof操作符确定它的类型

**不能使用对象字面量重写原型**

####寄生构造函数模式

> 创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新对象


```js
function Person(name,age){
	var o = new Object();
	o.name = name;
	o.age = age;
	o.sayName = function(){
		alert (this.name)
	}
	return o;
}

var person = new Person('shabi','30');
```

使用 `new` 操作符调用构造函数，通过在结尾使用`return`语句，可以重写调用构造函数时的返回值


```js
function newArray(){
	var values = new Array();
	values.push.apply(values,arguments);
	values.toPipedString = function(){
		return this.join('|')
	}
	return values;
}
var arr = new newArray('a','b','c');
arr.toPipedString(); // a|b|c
```

- 返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。
- 不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式

####稳妥构造函数模式

> 指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用


```js
function Person(name,age){
	var o = new Object();
	o.sayName = function(){
		alert (this.name)
	}
	return o;
}
// 除了使用 sayName()方法之外，没有其他办法可以访问name的值
var person = Person('shabi','30');
person.sayName(); // shabi

```

- 这种模式与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义

###继承

####原型链

**利用原型让一个引用类型继承另一个引用类型的属性和方法**

- 构成原型链
	1. 让原型等于另一个类型的实例，原型将包含一个指向另一个原型的指针
	2. 另一个原型中也包含着一个指向另一个构造函数的指针
	3. 另一个原型也是另一个类型的实例


```js
function SuperType(){
	this.property = true;
}
SuperType.prototype.getSuperValue = function(){
	return this.property;
}

function SubType(){
	this.subproperty = false;
}
//继承SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function(){
	return this.subproperty;
}

var instance = new SubType();
instance.getSuperValue(); // true
instance.getSubValue(); // false

//调用instance.getSuperValue()会经历三个搜索步骤：
// 1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.prototype
```


#####确定原型和实例的关系


```js
instance instanceof Object // true
instance instanceof SuperType // true
instance instanceof SubType // true
Object.prototype.isPrototypeOf(instance) // true
SuperType.prototype.isPrototypeOf(instance) // true
SubType.prototype.isPrototypeOf(instance) // true
```


- 给原型添加方法的代码一定要放在替换原型的语句之后


```js
function SuperType(){
	this.property = true;
}
SuperType.prototype.getSuperValue = function(){
	return this.property;
}

function SubType(){
	this.subproperty = false;
}
//继承SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function(){
	return this.subproperty;
}

SubType.prototype.getSuperValue = function(){
	return false;
}
var instance = new SubType();
instance.getSuperValue(); // false
```


- 通过原型链实现继承时，不能使用对象字面量创建原型方法
- 通过原型链实现继承时，原型实际上会变成另一个类型的实例，原先的实例属性也变成了现在的原型属性了
- 在创建子类型的实例时，不能向超类型的构造函数中传递参数

**不要单独使用原型链**

#####借用构造函数

- 在子类型构造函数的内部调用超类型构造函数，通过使用 `apply()` `call()` 再新创建的对象上执行构造函数


```js
function SuperType(){
	this.arr = ['a','b','c'];
}
function SubType(){
	SuperType.apply(this); //继承SuperType
}
// 创建SubType实例的环境下调用了SuperType构造函数
// 会在新的SubType对象上执行SuperType函数中定义的所有对象初始化代码

var instance = new SubType();
instance.arr.push('d');
instance.arr // a,b,c,d

var instance2 = new SubType();
instance2.arr // a,b,c
```

- 借用构造函数可以再子类型构造函数中向超类型构造函数传递参数


```js
function SuperType(name){
	this.name = name;
}
function SubType(){
	SuperType.apply(this,'shabi');
	this.age = '30';
}
var instance = new SubType();
instance.name // shabi
instance.age // 30
```


**方法都在构造函数中定义无法复用，超类型原型对子类型不可见，不要单独使用**

####组合继承

> 使用原型链实现对原型属性和方法的继承，而通过借用构造函数实现对实例属性的继承


```js
function SuperType(name){
	this.name = name;
	this.arr = ['a','b','c'];
}
SuperType.prototype.sayName = function(){
	alert (this.name);
}
function SubType(name,age){
	SuperType.apply(this,name);
	this.age = age;
}

SubType.prototype = new SuperType();
SubType.prototype.sayAge = function(){
	alert (this.age);
}

var instance = new SubType('shabi','30');
instance.arr.push('d');
instance.arr // a,b,c,d
instance.sayName(); // shabi
instance.sayAge(); // 30

var instance2 = new SubType('dashabi','20');
instance2.arr // a,b,c
instance2.sayName(); // dashabi
instance2.sayAge(); // 20
```


####原型式继承

> 借助原型可以基于已有的对象创建新的对象，同时不必因此创建自定义类型


```js
function object(o){
	function F(){};
	F.prototype = o;
	return new F();
}
// 在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型
// 最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制

var person = {
	name : 'shabi',
	friends : ['a','b','c']
}
var personB = object(person);
personB.name = 'dashabi';
personB.friends.push('d');

var personC = object(person);
personC.name = '2shabi';
personC.friends.push('e');

personC.friends // a,b,c,d,e
personB.friends // a,b,c,d,e
person.friends // a,b,c,d,e

// 新对象原型中就包含一个基本类型值属性和一个引用类型值属性。
// 这意味着person.friends不仅属于person所有，而且也会被personB以及personC共享
// 实际上，这就相当于又创建了person对象的两个副本
```


- `Object.create()` 接收两个参数：
	- 一个用作新对象原型（只有一个参数时等于object()方法）
	- 一个为新对象定义额外属性的对象（可选），与 `Object.defineProperties()` 方法相同，每个属性都通过自己的描述定义

```js
var personD = Object.create(person);
personD.name = 'D';
personD.friends.push('f')；
person.friends // a,b,c,e,f
personD.name // D
```


**在只想让一个对象与另一个对象保持类似的情况下使用，包含引用类型值的属性始终都会共享**

####寄生式继承

> 创建一个仅用于封装继承过程的函数，该函数再内部以某种方式增强对象，最后返回对象


```js
function createObject(o){
	var clone = Object.create(o);
	clone.sayHi = function(){
		alert ('hi')
	}
	return clone;
}

var person = {
	name:'shabi',
	age:'30'
}
var newObject = createObject(person);
newObject.sayHi(); // hi
// 新对象不仅有person的属性和方法，还有自己的方法
```


**在对象不是自定义类型和构造函数的情况下使用，此模式不能复用函数**

####寄生组合式继承

> 通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，不必为了指定子类型的原型而调用超类型的构造函数


```js
function inheritPrototype(subType,superType){
	// 两个参数：子类型构造函数和超类型构造函数

	var prototype = object(superType.prototype);
	// 创建超类型原型的副本

	prototype.constructor = subType;
	// 为副本添加constructor属性，弥补重写原型失去默认constructor属性

	subType.prototype = prototype;
	// 创建的新对象赋值给子类型的原型
}

function SuperType(name){
	this.name = name;
	this.arr = ['a','b','c'];
}
SuperType.prototype.sayName = function(){
	alert (this.name);
}
function SubType(name,age){
	SuperType.apply(this, name);
	this.age = age;
}
inheritPrototype(SubType,SuperType);

SubType.prototype.sayAge = function(){
	alert (this.age);
}
// 只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性
// 原型链保持不变；能够正常使用instanceof和isPrototypeOf()
```