##DOM扩展

###选择符API

> Selectors API Level 1的核心是两个方法：querySelector()和querySelectorAll()。在兼容的浏览器中，可以通过Document及Element类型的实例调用它们。目前已完全支持Selectors API Level 1的浏览器有IE 8+、Firefox 3.5+、Safari 3.1+、Chrome和Opera 10+


####querySelector()方法

- `querySelector()` 接收一个CSS选择符，返回匹配的第一个元素，无匹配返回null，传入不支持的Css选择符会出错
- 通过 `Element` 类型调用 `querySelector()` 会从该元素后台范围内查找

####querySelectorAll()方法

- `querySelectorAll()` 返回一个 `NodeList` 的实例，不会不断对文档进行搜索的动态查询，无匹配返回 `[]`
- 使用 `item()` 方法或者 `[]` 取得 `NodeList` 中的某个元素

###元素遍历

- childElementCount:返回子元素（不包括文本节点和注释）的个数
- firstElementChild:指向第一个子元素；firstChild的元素版
- lastElementChild：指向最后一个子元素；lastChild的元素版
- previousElementSibling：指向前一个同辈元素；previousSibling的元素版
- nextElementSibling:指向后一个同辈元素；nextSibling的元素版

```js
var i,len,
	child = element.firstElementChild;
while(child != element.lastElementChild){
	child // 是元素
	child = child.nextElementSibling;
}
```

####HTML5与类相关的扩充

- `getElementsByClassName()` 可以通过 `document` 或所有HTML元素调用，返回带有指定类的所有元素的 `NodeList`

```js
// 类名的先后顺序不重要
var allCurrentUsernames = document.getElementsByClassName('username current');
// #myDiv 元素中带有 selected 类名的元素
var selected = document.getElementById('myDiv').getElementsByClassName('selected');
```

- `classList` 属性可以用来添加、删除、替换类名

```html
<div class="a">...</div>
```

```js
var div = document.getElementsByClassName('a');
div.classList.remove('a')
div.classList.add('b')
div.classList.toggle('c')
```

####HTML5焦点管理

- `document.activeElement` 始终会引用DOM中获得了焦点的元素
- `document.hasFocus()` 检测文档是否获取了焦点，可以知道用户是否在与页面交互

```js
var button = document.getElementById('myButton');
button.focus();
document.activeElement === button; // true
document.hasFocus(); // true
```

####HTML5 HTMLDocument的变化

- `document.readyState` 文档是否已经加载完成 `loading` 正在加载 `complete` 加载完毕
- 兼容模式检测 `document.compatMode`： `CSS1Compat`-标准模式 `BackCompat`-兼容模式
- `document.head` 引用文档的 `head` 元素

```js
var head = document.head || document.getElementByTagName('head')[0];
```

####HTML5 字符集属性

- `document.charset` 可以获取文档实际使用的字符集，也可以通过此属性修改
- `document.defaultCharset` 浏览器及操作系统默认设置

####HTML5 自定义数据属性

- 为元素添加非标准的属性，前缀为 `data-`
- 通过 `dataset` 属性访问或设置自定义属性的值，`dataset` 属性的值是 `DOMStringMap` 的一个实例

####插入标记

- `innerHTML` 返回与调用元素的所有子节点（包括元素、注释、文本节点）对应的HTML标记（每个浏览器返回值不一样）
- `innerHTML` 写模式会根据指定的值创建新的DOM树，会完全替代调用元素的所有子节点，（注意引号转义）
- `outerHTML` 返回调用它的元素及所有子节点的HTML标签
- `outerHTML` 写模式会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素
- `insertAdjacentHTML()` 接收两个参数：插入位置和HTML文本
	- `beforebegin` 作为前一个元素同辈元素
	- `afterbegin` 作为第一个子元素
	- `beforeend` 作为最后一个子元素
	- `afterend` 作为后一个同辈元素

> 删除带有事件处理程序或引用了其他JavaScript对象子树时，就有可能导致内存占用问题。在使用innerHTML、outerHTML属性和insertAdjacentHTML()方法时，最好先手工删除要被替换的元素的所有事件处理程序和JavaScript对象属性

> 避免多次调用插入或删除元素方法

- `scrollIntoView()` 可以在所有HTML元素上调用，调用元素就可以出现在视口中
	- true作为参数，或者不传入任何参数，那么窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐
	- 传入false作为参数，调用元素会尽可能全部出现在视口中
- `contains()` 某个节点是不是另一个节点的后代，不通过在DOM文档树中查找

```js
el !== child && el.contains(child);
```

####插入文本

- `innerText` 会返回子文档树中所有的文本拼接起来，写入时会删除元素所有子节点
- 设置 `innerText` 永远只会生成当前节点的一个子文本节点，可以通过 `innerText` 属性过滤掉HTML标签。方法是将 `innerText` 设置为等于 `innerText`，可以去掉所有HTML标签
- `outerText` 读取模式等于 `innerText` ，写模式会用新的文本节点代替调用此方法的元素（不常用）

```js
el.innerText = el.innerText;

// 兼容所有浏览器
function getInnerText(el){
	if(typeof el.textContent == 'string'){
		return el.textContent;
	}else{
		return el.innerText;
	}
}
function setInnerText(el, text){
	if(typeof el.textContent == 'string'){
		el.textContent = text;
	}else{
		el.innerText = text;
	}
}

```