##函数

###函数对象

- 函数对象连接到 `Function.prototype` (该原型本身连接到 `Object.prototype` )
- 每个函数在创建时会附加：函数的上下文 和 实现函数行为的代码 两个隐藏属性
- 每个函数在创建是也配有一个 `prototype` 属性，它的值是一个拥有 `constructor` 属性且值即为该函数的对象
- 函数可以保存在变量、对象、数组中，可以被当做参数传给其他函数，可以返回函数，函数也是对象，所以函数也可以拥有方法

###函数字面量

```js
var add = function(a,b){
	return a+b;
}
```

- 函数字面量可以出现在任何允许表达式出现的地方
- 函数除了可以访问自己的参数和变量，也能访问把它嵌套在其中的付函数的参数与变量
- 通过函数字面量创建的函数对象包含一个连到上下文的连接 - 闭包

###调用

- `this` 值取决于调用的模式
- `arguments` 个数与形式参数 `parameters` 个数不匹配时，不会出错
- 任何类型的值都可以被传递给任何参数

###方法调用模式

- *方法*：当一个函数被保存为对象的一个属性
- 当方法被调用时，`this` 被绑定到该对象

```js
var obj = {
	value:0,
	increment: function(inc){
		this.value += typeof inc === 'number' ? inc : 1;
	}
}
obj.increment();
obj.value; // 1
obj.increment(2);
obj.value; // 3
```

###函数调用模式

- 当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的
- `this` 被绑定到全局对象

```js
var sum = add(3,4); // 7

obj.double = function(){
	var that = this;
	var helper = function(){
		that.value = add(that.value,that.value);
	}
	helper();
}
```

###构造器调用模式

- 如果使用 `new` 操作符调用一个函数，会创建一个连接到该函数的 `prototype` 城院的新对象，同时 `this` 也会绑定到那个新对象上
- 按照约定，构造器函数大写开头命名的变量中

```js
var Quo = function(name){
	this.name = name;
}
Quo.prototype.get_name = function(){
	return this.name;
}
var myQuo = new Quo('confused');
myQuo.get_name(); // confused
```

###Apply调用模式

- `apply` 方法构建一个参数数组传递给调用函数，接收：要绑定的 `this` 和 参数数组两个参数

```js
var arr = [3,4];
var sum = add.apply(null, arr); // 7

var obj = {
	name: 'ok'
}
var status = Quo.prototype.get_name.apply(obj);  // ok
```

###参数

- 当函数被调用时会得到一个参数数组 `arguments`，没有数组的任何方法

###返回

- `return` 语句可以用来使函数提前返回
- 如果用 `new` 调用，则返回 `this` 对象

###异常

- 当程序的正常流程收到干扰时，应该抛出一个异常

```js
var add = function(a,b){
	if(typeof a !== 'number' || typeof b !== 'number'){
		throw {
			name: 'TypeError',
			message: 'add needs numbers'
		};
	};
	return a + b;
};
```

- `throw`语句中断函数执行，抛出一个 `exception` 对象

```js
var try_it = function(){
	try {
		add('one')
	}catch(e){
		e.name; // TypeError
		e.message; // add needs numbers
	}
}
try_it();
```

###扩充类型的功能

- JS允许给基础类型扩充功能

```js
Function.prototype.method = function(name, func){
	this.prototype[name] = func;
	return this;
}
Function.prototype.method = function(name, func){
	if(!this.prototype[name]){ // 确定没有该方法时才添加
		this.prototype[name] = func;
	}
	return this;
}
```

###递归

- 递归函数就是会直接或简介调用自身的一种函数，把问题分解为一组相似的子问题，每一个都用一个*寻常解*去解决

```js
var walk_the_dom = function walk(node,func){
	func(node);
	node = node.firstChild;
	while(node){
		walk(node,func);
		node = node.nextSibling;
	}
}

var getElementsByAttribute = function(att,value){
	var result = [];
	walk_the_dom(document.body,function(node){
		var actual = node.nodeType === 1 && node.getAttribute(att);
		if(typeof actual === 'string' && (actual == value || typeof value !== 'string')){
			result.push(node)
		}
	})
	return result;
}
```

###作用域

- 作用域控制着变量与参数的可见性及生命周期
- 定义在函数中的参数和变量在函数外部是不可见的，而在一个函数内部任何位置定义的变量，在该函数内部任何地方都可见
- 在函数顶部声明函数中可能用到的所有变量

```js
var foo = function(){
	var a = 3,b = 5;
	var bar = function(){
		var b = 7,c = 11; // a = 3
		a += b + c; // a = 21
	}
	// a = 3, b = 5, c undefined
	bar();
	// a = 21, b = 5
}
```

###闭包

- 内部函数拥有比它外部函数更长的生命周期
- 函数内部被返回的方法仍然可以访问函数内部的参数或属性，而且访问的不是参数的副本，而是该参数本身，函数可以访问它被创建时所处的上下文环境，被称为闭包

> 内部函数能访问外部函数的实际变量而无须复制

```js
var obj = (function(){
	var value = 0;
	return {
		increment: function(inc){
			value += typeof inc === 'number' ? inc : 1;
		},
		getValue:function(){
			return value;
		}
	}
}());
// 内部变量value对作用域外部总是不可见的
// 并没有赋值给obj，而是把调用该函数后返回的结果赋值给它，最后的 ()
```

```js
var handlers = function(nodes){
	var i;
	for (i = 0; i < nodes.length; i++){
		nodes[i].onclick = function(e){
			alert (i); // i 一直表示节点的数量
		}
	}
}
// handlers 函数绑定了变量 i 本身，而不是函数在构造时的变量 i

var handlers = function(nodes){
	var helper = function(i){
		return function(){
			alert (i);
		}
	}
	var i;
	for (i = 0; i < nodes.length; i++){
		nodes[i].onclick = helper(i);
	}
}
```

> 避免在循环中创建函数

###回调

- 处理不连续的事件

###模块

- 使用函数和闭包构造模块，模块是一个提供接口到隐藏状态与实现的函数或对象
- 定义了私有变量和函数的函数，利用闭包创建可以访问私有变量和函数的特权函数，最后返回这个特权函数或保存到其他地方
- 使用模块模式可以完全抛弃全局变量

```js
String.prototype.deentityify = (function(){
	var enity = {
		quot: '"',
		lt:'<',
		gt:'>'
	};
	return function(){
		return this.replace(/&([^&;]+);/g,function(a,b){
			var r = enity[b];
			return typeof r === 'string' ? r : a;
		})
	}
}());
// 最后的 () 立刻调用构造出来的函数，创建并调用返回的函数才是deentityify方法
// 只有 deentityify 才能访问 enity 对象

var serial_maker = function(){
	var perfix = '';
	var seq = 0;
	return {
		set_perfix: function(p){
			perfix = String(p)
		},
		set_seq: function(s){
			seq = s;
		},
		gensym: function(){
			var result = perfix + seq;
			seq += 1;
			return result;
		}
	}
}
var seqer = serial_maker();
seqer.set_perfix('@@');
seqer.set_seq(100);
var unique = seqer.gensym(); // @@100
```

###级联

- 如果让一个不返回任何值的方法返回 `this` 就可以启用级联
- 在一个级联中，可以用单独一条语句中依次调用同一个对象的很多方法

###柯里化

- 柯里化也称局部套用，把多参数的函数转换为一系列单参数函数并进行调用
- 柯里化允许把函数与传递给它的参数结合，产生一个新的函数
- curry通过创建一个保存着原始函数和要被套用的参数的闭包来工作，返回一个函数，该函数被调用时，会返回调用原始函数的结果，并传递调用curry时的参数加上当前调用的参数

```js
Function.prototype.curry = function(){
	var slice = Array.prototype.slice,
		args = slice.apply(arguments),
		that = this;
	return function(){
		return that.apply(null,args.concat(slice.apply(arguments)));
	}
}

var add = function(a,b){
	return a+b;
};
var add1 = add.curry(1);
add1(6); // 7
```

###记忆

- 函数可以将先前的计算结果记录在某个对象里，从而避免重复运算

```js
var fib = function(n){
	return n < 2 ? n : fib(n - 1) + fib(n - 2);
}

var fib2 = function(){
	var memo = [0,1];
	var fib = function(n){
		var result = memo[n];
		if(typeof result !== 'number'){
			result = fib(n - 1) + fib(n - 2);
			memo[n] = result;
		}
		return result;
	}
	return fib;
}();
// fib2 中，把已运算过的结果记录在memo中并隐藏在闭包中
// 当函数被调用时，先检测运算结果是否已经存在
```

```js
var memoizer = function(memo, formula){
	var recur = function(n){
		var result = memo[n];
		if(typeof result !== 'number'){
			result = formula(recur, n);
			memo[n] = result;
		}
		return result;
	}
	return recur;
}

var fib = memoizer([0,1],function(recur,n){
	return recur(n-1) + recur(n-2);
})
```