## 一.let 和 const 命令

### let

- 所声明变量只在 `let` 命令所在代码块内有效
- 不存在变量提升
- 暂时性死区（在代码块中，使用`let` 声明变量之前，变量不可用）
- 不允许在相同作用域内重复声明同一个变量

### 块级作用域

- 变量只在当前代码块内有效
- 作用域可以任意嵌套 `{{{{{{let a = 'shabi'}}}}}}`
- 函数本身的作用域在其所在的块级作用域内

```javascript
let f;
{
  let a = 'shabi';
  f = function(){
    return a;
  }
}
f(); // shabi
```

### const

- 声明常量，一旦声明，值不会改变，必须立刻初始化，不能留到以后再赋值
- 只在声明所在的块级作用域内有效
- 常量不指向数据而指向数据所在的地址，指向的数组、对象依然可更新

### 跨模块常量

```javascript
// constants.js 模块
export const A = 1;
//test1.js 模块
import * as constatns form './constants';
constants.A; //1
//test2.js 模块
import {A} form './constants'
A; //1
```

### 全局对象的属性

- `var` `function` 声明的全局变量依旧是全局对象的属性
- `let` `const` `class` 声明的全局变量不属于全局对象

----



## 二、变量的解构赋值

> 从数组或对象中提取值，对变量进行赋值 - Destructuring

### 数组的解构赋值

```javascript
let [a,b,c] = [1,2,3]
// 从数组中提取值，按照对应关系对变量赋值

let [foo,[[bar],baz]] = [1,[[2],3]];
foo //1
bar //2
baz //3

let [,,third] = [1,2,3];
third //3
```

- 解构不成功，变量为 `undefined`
- 只要数据具有 `iterator` 接口即可解构

#### 默认值

```javascript
let [x,y='0'] = ['a'];
x //a
y //0
```

- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明

```javascript
let [x=1,y=x] = [2];
x //1
y //2

let [x=y,y=1] = []; // ReferenceError
```

### 对象的解构赋值

- 对象的属性没有顺序，变量名必须与属性名相同才能正确赋值
- 如果变量名与属性名不一致，须在声明时指定一个相同的属性名
- 默认值在属性名严格等于`undefined` 时才生效

> 对象的解构赋值内部机制为，先找到同名的属性，然后再赋值给对应的变量，真正的赋值的是后者而不是前者

```javascript
let {foo,bar,baz,foo:x} = {foo:'a',bar:'b'};
foo //a
bar //b
baz //undefined
x //a 被赋值的是x，而不是foo

let obj = {
  p:[
    'hello',
    {y:'world'}
  ]
}
let {p:[x,{y}]} = obj; //p是模式，不是变量，所以不会被赋值
x //hello
y //world

let node = {
  loc:{
    start:{
      line:1,
      column:5
    }
  }
}
let {loc:{start:{line}}} = node; //loc start都是模式
loc,start //undefined
line //1

let obj = {},arr = [];
({foo:obj.prop,bar:arr[0]}={foo:123,bar:true}) // es6会将{}识别为作用域块，用()解释为代码块
obj.prop //123
arr //[true]
```

### 字符串的解构赋值

- 被解构的字符串会被转换为一个类似数组的对象
- 类似数组的对象有`length` 属性，可以对这个属性解构赋值

```javascript
const [a,b,c,d,e] = 'hello';
a //h
let {lenght:len} = 'hello';
len //5
```

### 数值和布尔值的解构赋值

- 等号右边是数值或布尔值时，先会被转换成对象

```javascript
let {toString:s} = 123;
s === Number.prototype.toString //true 将s赋值为Number的toString方法
```

### 函数参数的解构赋值

- `functoin add({x=0,y=0}={}){}` 参数中变量x和变量y的默认值
- `function add({x,y} = {x:0,y:0})` 为函数参数指定默认值，而不是为x和y提供默认值

```javascript
function add([x,y]){ //[x,y]不是一个数组，而是通过解构得到的变量x,y
  return x+y;
}

[[1,2],[3,4]].map([a,b] => a+b)
//[3,7]

[1,undefined,3].map((x='yes') => x);
//[1,yes,3]
```

### 圆括号

- 解构赋值中不能使用圆括号的情况
  - 变量声明语句中，模式不能带有圆括号
  - 函数参数中不能带有圆括号（函数参数也属于变量声明）
  - 不能将整个模式或嵌套模式中的一层放在圆括号中
- 只有赋值语句的非模式部分可以使用圆括号

### 用途

#### 交换变量的值

```javascript
[x,y] = [y,x]
```

#### 从函数返回多个值

```javascript
function add(){
  return [1,2,3,4]
}
let [a,b,c,d] = add();

function ex(){
  return {
    foo:1,
    bar:2
  }
}
let {foo,bar} = ex();
```

#### 函数参数的定义

- 解构赋值可以方便的将一组参数与变量名对应

```javascript
function f([x,y,z]){}
f([1,2,3]) //有序值
function o({x,y,z}){}
f({x:3,z:1,y:0}) //无序值
```

#### 提取JSON数据

```javascript
var jsonDATA = {
  id:1,
  name:'shabi'
}
let {id,name} = jsonDATA;
id //1
name //shabi
```

#### 函数参数的默认值

```javascript
var add = function({a=1,b=2}={}){
  return a+b
}
add() //3
add(10,10) //3
add({a:20,b:20}) //40
```

#### 遍历Map结构

```javascript
var map = new Map();
map.set('key','value');
for(let [key,value] of map){ // [key]获取键名 [,value]获取值名
  key //key
  value //value
}
```

#### 输入模块的指定方法

```javascript
const {A,B} = require(constants)
```

---



## 三、字符串的扩展

### 字符的unicode表示法

- 将码点放入大括号就能正确解读字符 `\u{20BB7} = 𠮷` `\u{41}\u{42}\u{43} = abc`

### codePointAt()

- 返回32位的 UTF-16 字符的码点
- 可以检测字符是2字节字符还是4字节字符 `str.codePointAt(0) > 0xFFFF`

### String.fromCodePoint()

- 从码点返回字符 `String.fromCOdePoint(0x20BB7) = 吉`

### 字符串遍历器接口

- 字符串可以使用 `for-of` 循环遍历

### ~~at() (ES7)~~

- `'abc'.at(0) = a`

### normalize()

- 将字符的不同表现方法统一为同样的形式 （比如带有重音符号的字符）

### includes(), startsWith(), endsWith()

- `includes()` 表示是否找到了参数字符串
- `startsWith()` 表示是否以参数字符串开头
- `endsWith()` 表示是否以参数字符串结尾
- 第二个参数表示开始搜索的位置

### repeat()

- 返回新字符串，将原字符串重复n次

### ~~padStart(), padEnd() (ES7)~~

- 字符串补全，接收最小长度和用来补全的字符串

### 模板字符串

- 使用 **`** 号标识模板字符串，是增强版的字符串

```javascript
let name = 'shabi';
`hello ${name} \`\`` //hello shabi ``

`hello ${'da ' + name}` //hello da shabi
```

### 标签模板

- 将模板字符串跟在一个函数名后面，该函数将被调用来处理这个模板字符串
- 标签是一个函数，整个表达式返回的值就是标签函数处理整个模板字符串后的解构
- 标签函数接受到的第一个参数是模板字符串中没有变量替换的部分组成的数组
- 第一个参数还有一个`raw`属性，会将`\n` 识别为 `\` 和 `n` 两个字符，这样可以获得转义之前的原始模板

```javascript
let total = 30;
let msg = passthru`the total is ${total} (${total * 1.05} with tax)`;
function passthru(values){
  let i=0,result='';
  while(i<values.length){
    result += values[i++];
    if(i<arguments.length){
      result += arguments[i]
    }
  }
  return result;
}
//传入的参数为所有字符拼接成的数组the total is,(,with tax)三个部分
//拼接total变量到result
msg; //the total is 30 (31.5 with tax)
```

### String.raw()

- 返回一个 `\`都被转义的字符串
- 作为处理模板字符串的基本方法，会替换所有的变量并对 `\` 进行转义

---



## 四、正则的扩展

### RegExp构造函数

- RegExp构造函数允许接受正则表达式作为参数，返回一个原有正则表达式的拷贝 `var regex = new RegExp(/xyz/i)` 
- 如果 RegExp 构造函数接收第二个参数指定的修饰符，则会忽略原有的正则修饰符

### 字符串的正则方法

- 所有与正则有关的方法全部调用 RegExp 的实例方法
  - String.prototype.match 调用 RegExp.prototype[Symbol.match]
  - String.prototype.replace 调用 RegExp.prototype[Symbol.replace]
  - String.prototype.search 调用 RegExp.prototype[Symbol.search]
  - String.prototype.split 调用 RegExp.prototype[Symbol.split]

### u修饰符

- u修饰符表示unicode模式，用来处理 \uFFFF的unicode字符

#### .字符

- 对于码点大于0xFFFF的字符 `.` 字符不能识别，须配合u修饰符使用

```javascript
var s = '\u{20BB7}';
/^.$/.test(s); //false
/^.$/u.test(s); //true
```

#### unicode字符表示法

- 使用{}表示的unicode字符，必须使用u修饰符

#### 量词

- {}内配合u修饰符不会被识别为量词

```javascript
/𠮷{2}/.test('𠮷𠮷') //false
/𠮷{2}/u.test('𠮷𠮷') //true
```

#### 预定义模式

```javascript
//使用u修饰符和\s 预定义模式正确返回字符串长度
function codePointLength(text){
  var result = text.match(/[\s\S]/gu);
  return result ? result.length : 0
}
```

### y修饰符

> 沾连（sticky）修饰符

- 作用为全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始

```javascript
let s = 'aaa_aa_a';
let r1 = /a+/g;
let r2 = /a+/y;

r1.exec(s); //['aaa']
r2.exec(s); //['aaa']
//剩余字符串为 _aa_a

r1.exec(s); //['aa']
r2.exec(s); //null

let r3 = /_a+/y;
r3.exec(s) //['aaa_']
r3.exec(s) //['aa_']
```

### sticky属性

- 表示正则对象中是否使用了y修饰符

### flags属性

- 表示正则表达式的修饰符

### ~~RegExp.escape() (ES7)~~

- 字符串必须转义才能作为正则表达式

---



## 五、数值的扩展

### 二进制和八进制数值表示法

- 使用 `0b` 或 `0B` 表示二进制 `Number(0b111) = 7`
- 使用 `0o` 或 `00` 表示八进制 `Number(0010) = 8`

### Number.isFinite()和Number.isNaN()

- `Number.isFinite()` 检测是否为非无穷数
- 对非数值一律返回false，不做类型转换

### Number.parseInt() 、Number.parseFloat()

- 行为与 `parseInt` 和 `parseFloat` 一致，但移植到了Number对象上

### Number.isInteger()

- 判断是否为整数，`3 === 3.0`

### Number.EPSILON

- 一个极小的常量，为浮点数计算设置一个范围误差
- 浮点误差小于 `Number.EPSILON` 即可认为得到了争取的结果

```javascript
0.1 + 0.2 // 0.30000000000000004
function withinErrorMargin(left,right){
  return Math.abs(left - right) < Number.EPSILON
}
withinErrorMargin(0.1+0.2,0.3) //true
withinErrorMargin(0.1+0.2,0.4) //false
```

### 安全整数和Number.isSafeInteger()

- `Number.MAX_SAFE_INTEGER` 和 `Number.MIN_SAFE_INTEGER` 两个常量表示整数范围上下限
- `Number.isSafeInteger()` 判断一个整数是否落在安全范围内**（使用时须验证每一个参与运算的数值）**

### Math对象的扩展

- Math.trunc() 去除一个数的小数部分
- Math.sign() 判断一个数是正数、负数、0 ，正数返回+1，负数返回-1，0返回0，-0返回-0，其他值返回NaN
- Math.cbrt() 返回一个数的立方根
- Math.clz32() 返回一个数的32位无符号整数形式有多少个前导0
- Math.imul() 返回两个数以32位带符号整数形式相乘的结果
- Math.fround() 返回一个数的单精度浮点数形式
- Math.hypot() 返回所有参数的平方和的平方根
- Math.expm1(x) 返回e^x-1
- Math.log1p(x) 返回 \ln(1+x)
- Math.log10(x) 返回以10为底x的对数
- Math.log2(x) 返回以2为低x的对数

### 指数运算符 *（ES7，babel可用）*

- `2 ** 2 = 4` `a **= 2 //a =a * a` `b **= 3 //b = b*b*b`

---



## 六、数组的扩展



