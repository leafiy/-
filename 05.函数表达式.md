##函数表达式

- `function` 函数声明提升-执行代码之前会先读取函数声明
- 函数表达式，函数是匿名函数

###递归

- 一个函数调用自身

```js
function factorial(num){
	return num * factorial(num - 1)
}
function factorial(num){
	return num * arguments.callee(num - 1)
}
var factorial = (function f(num){ // 严格模式使用
	return num * f(num - 1)
})
```


- 函数内部使用 `argunments.callee` 更保险

###闭包

> 闭包是指有权访问另一个函数作用域中的变量的函数，创建方式：在一个函数内部创建另一个函数

**当某个函数第一次被调用时，会创建一个执行环境 `execution context` 及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（即`[[Scope]]`）。然后，使用 `this` `arguments` 和其他命名参数的值来初始化函数的活动对象 `activationobject` 但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量**

```js
function createComparisonFcuntion(propertyName){
	return function(object1, object2){
		var val1 = object1[propertyName]; // 访问了外部函数中的变量propertyName
		var val2 = object2[propertyName];
		if(val1 < val2){
			return -1;
		}else if(val1 > val2){
			return 1;
		}else{
			return 0;
		}
	}
}
// 内部匿名函数的作用域链包含createComparisonFcuntion的作用域


function compare(val1,val2){
	if(val1 < val2){
		return -1;
	}else if(val1 > val2){
		return 1;
	}else{
		return 0;
	}
}
var result = compare(5,10);
// 在第一次调用compare()时，创建一个包含 this arguments val1 val2 的活动对象
// 全局执行环境的变量对象（包含this result compare）在 compare() 执行环境的作用域链中处于第二位
// 全局环境的变量对象始终存在，compare()的局部变量对象只在函数执行过程中存在
// compare() 函数的执行环境包含本地活动对象和全局变量对象
```

- 作用域链本质上是一个指向变量对象的指针列表，只引用但不实际包含变量对象
- 在函数中访问一个变量时，会从作用域链中搜索相应名字的变量，当函数执行完毕后，局部活动对象销毁，内存中只保留全局作用域
- 在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链中
- **在外部函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数的活动对象**

```js
var compare = createComparisonFcuntion('name');
var result = compare({name:1},{name:2});

// 在匿名函数从createComparisonFunction()中被返回后
// 它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象
// 匿名函数就可以访问在createComparisonFunction()中定义的所有变量
// createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁
// 当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中
// 直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁

compare = null; // 解除对compare的引用，销毁匿名函数的作用域链，释放内存
```

####闭包与变量

- 闭包只能去的包含函数中任何变量的最后一个值

```js
function createFunction(){
	var arr = [];
	for(var i=0;i<2;i++){
		arr[i] = function(){
			return i;
		}
	}
	return arr;
}
// [function, function]
// 每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i
// createFunctions()返回后，变量i的值是1，每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部i的值都是1

function createFunction(){
	var arr = [];
	for(var i=0;i<2;i++){
		arr[i] = function(num){
			return function(){
				return num
			}
		}(i)
	}
	return arr;
}
// 没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组
// 匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，传入了变量i
// 由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num
// 而在这个匿名函数内部，又创建并返回了一个访问num的闭包
// arr数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的数值了
```

####关于this对象

- this对象是在运行时基于函数的执行环境绑定的
	- 在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象
	- 匿名函数的执行环境具有全局性，因此其this对象通常指向window

```js
var name = 'shabi';
var o = {
	name: 'this object',
	getName: function(){
		return function(){
			return this.name;
		}
	}
}
o.getName()(); // shabi

var o2 = {
	name: 'this object',
	getName: function(){
		var that = this; // 把外部作用域中的this对象保存在一个闭包能够访问到的变量里
		return function(){
			return that.name;
		}
	}
}
o2.getName()(); // this object
// that 是在包含函数中特意声名的一个变量。即使在函数返回之后，that也仍然引用着o2
// this和arguments也存在同样的问题
// 如果想访问作用域中的arguments对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中

var o3 = {
	name : 'this object',
	getName: function(){
		return this.name;
	}
}
o3.getName(); // this object
(o3.getName()); // this object
(o3.getName = o3.getName)(); // shabi 赋值表达式的值是函数本身，所以this的值不能得到维持
```

####内存泄露

- 闭包的作用域链中保存的HTML元素，将无法被销毁

```js
function handler(){
	var el = document.querySelectorAll('body')[0];
	el.onclick = function(){
		alert (el)
	}
}
// 匿名函数保存了一个对handler()的活动对象的引用，因此就会导致无法减少el的引用数
// 只要匿名函数存在，el的引用数至少也是1，因此它所占用的内存就永远不会被回收

function handler2(){
	var el = document.querySelectorAll('body')[0];
	var id = el.id;
	el.onclick = function(){
		alert (id);
	}
	el = null;
}
// 把id的副本存在一个变量中，并在闭包中引用该变量消除循环引用
// 把el变量设置为null，这样就能够解除对DOM对象的引用
```

###模仿块级作用域

- 再块语句中定义的变量，实际上是在包含函数中而非语句中创建的

```js
function num(count){
	for (var i=0; i < count; i++){
		console.log (i)
	}
	console.log (i) // count
	var i;
	console.log (i) // count
}
// 变量i定义在 num() 的活动对象中

(function(){
	// 这里是块级作用域
})()
// 将函数声明包含在()中，表示是一个函数表达式，后面的()会立刻调用这个函数

function num(count){
	(function(){
		for (var i=0; i < count; i++){
			console.log (i)
		}
	})()
	// 匿名函数执行后，其中的变量被销毁
	// 匿名函数是一个闭包，所以能访问作用域中的所有变量
	console.log (i) // 出错
}
```

- 模仿块级作用域在全局作用域中被用在函数外部，限制项全局作用域中添加过多的变量和函数

```js
(function(){
	var now = new Date();
	if(now.getMonth() == 0 && now.getDate() == 1){
		alert ('new year')
	}
	// now 是匿名函数中的局部变量
	// 减少闭包占用内存的问题，没有指向匿名函数的引用，只要匿名函数执行完毕立即销毁其作用域链
})()
```

###私有变量

- 任何在函数中定义的变量，不能再函数外部访问，都可以认为是私有变量
- 如果在函数内创建闭包，闭包通过自己的作用域链也可以访问在函数内部定义的变量
- 在构造函数中定义特权方法 （*有权访问私有变量和私有函数的公有方法*）

```js
function MyObject(){
	// 私有变量和函数
	var privateVariable = 10;
	function privateFunction(){
		return false;
	}
	// 特权方法
	this.publicMethod = function(){
		privateVariable++;
		return privateFunction();
	}
}
var someFunction = new MyObject();
someFunction.publicMethod(); // false
// 变量privateVariable和函数publicMethod()只能通过特权方法访问
```

- 利用私有和特权成员，可以隐藏不应该被直接修改的数据

```js
function Person(name){
	this.getName = function(){
		return name;
	}
	this.setName = function(value){
		name = value;
	}
}
var person = new Person('shabi');
person.getName(); // shabi
person.setName('dashabi');
person.getName(); // dashabi
```

**构造器模式缺点：每个实例都会创建同样一组新方法，不要使用**


####静态私有变量

- 在私有作用域中定义私有变量或函数

```js
(function(){
	var privateVal = 10;
	function privateFunc(){
		return false;
	}
	// 构造函数
	MyObject = function(){}; // 函数声明只能创建局部函数，使用表达式
	// 没有使用var，所以MyObject就成了一个全局变量，能够在私有作用域之外被访问到

	// 公有特权方法
	MyObject.prototype.publicMethod = function(){
		privateVal++;
		return privateFunc();
	}
})();
// 特权方法是在原型上定义的，因此所有实例都是用同一个函数
// 特权方法作为一个闭包，保存着对作用域的引用
```

```js
(function(){
	var name = '';
	Person = function(value){
		name = value;
	}
	Person.prototype.getName = function(){
		return name;
	}
	Person.prototype.setName = function(value){
		name = value;
	}
})();
var person1 = new Person('shabi');
person1.getName(); // shabi
person1.setName('dashabi');
person1.getName(); // dashabi

var person2 = new Person('2shabi');
person1.getName(); // 2shabi
person2.getName(); // 2shabi

// Person构造函数与getName和setName都有权访问私有变量name
// name变成一个静态、由所有实例共享的属性
```

> 多查找作用域链中的一个层次，就会在一定程度上影响查找速度。而这正是使用闭包和私有变量的一个显明的不足之处

####模块模式

- 为单例（singleton - 只有一个实例的对象）创建私有变量和特权方法

> 按照惯例，以对象字面量方式创建单例对象

```js
var singleton = {
	name : value,
	method : function(){
	// 方法代码
	}
}
```

```js
var singleton = function(){
	var privateVal = 10;
	function privateFunc(){
		return false;
	};
	return {
		publicProperty : true,
		publicMethod : function(){
			privateVal++;
			return privateFunc();
		}
	}
	// 返回的对象中只包含可以公开的属性和方法
	// 返回的对象是单例的公共接口
}();
```

- 单例通常都是作为全局对象，不会将他传给一个函数
- 如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式


####增强的模块模式

> 适合单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况

```js
var singleton = function(){
	var privateVal = 10;

	function privateFunc(){
		return false;
	}

	var o = new CustomType();
	o.publicProperty = true;
	o.publicMethod = function(){
		privateVal++;
		return privateFunc();
	}
	return o;
}();
```