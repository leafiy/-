##继承

###伪类 Pseudoclassical （糟粕）

- 由于语法问题，通过构造器函数产生对象，导致不直接让对象从其他对象继承
- 当一个函数对象被创建时， `Function` 构造器产生的函数对象会带有以下效果

```js
this.prototype = { constructor: this }
```

- 新的对象被赋予一个包含了 `constructor` 属性的 `prototype` 属性
- 新对象的 `constructor` 属性值为该新函数
- `prototype` 对象是存放继承特性的地方，由于js没有方法确定哪个函数是用来做构造器的，所以每个函数都有 `prototype`
- 使用 `new` 操作符调用一个函数，函数执行方式会被修改

```js
Function.prototype.method = function(name, func){
	if(!this.prototype[name]){
		this.prototype[name] = func;
	}
	return this;
}

Function.method('new', function(){
	var that = Object.create(this.prototype);
	var other = this.apply(that,arguments);
	return (typeof other === 'object' && other) || that
})

var Mammal = function(name){
	this.name = name;
};
Mammal.prototype.get_name = function(){
	return this.name;
}
Mammal.prototype.says = function(){
	return this.saying || '';
}

var myMammal = new Mammal('shabi');
var name = myMammal.get_name(); // shabi

var Cat = function(name){
	this.name = name;
	this.saying = 'meow';
};
Cat.prototype = new Mammal();
Cat.prototype.purr = function(n){
	var s = '';
	for (var i = 0;i<n;i++){
		if(s){
			s+='-';
		}
		s+= 'r'
	}
	return s;
}
Cat.prototype.get_name = function(){
	return this.says() + '' + this.name + '' + this.says();
}
var myCat = new Cat('dashabi');
var says = myCat.says();
var purr = myCat.purr(10);
var name = myCat.get_name();
```

**很复杂，尽量不要使用 `new` 和构造器**

###对象说明符 Object Specifiers

- 使用JSON对象传递参数给构造器

```js
var obj = maker(f,g);

//改成
var obj = maker({
	f:f,
	g:g
})
```

###原型 Prototypal

- 一个新对象可以继承一个旧对象的属性
- 构造一个对象，可以构造更多和那个对象类似的对象，避免把一个应用拆解成一系列嵌套抽象类的分类过程

```js
var myMammal = {
	name : 'mammal',
	get_name: function(){
		return this.name;
	},
	says:function(){
		return this.saying || '';
	}
}

// 利用Object.create方法实现差异化继承
var myCat = Object.create(myMammal);
myCat.name = 'shabi';
myCat.saying = 'meow';
myCat.get_name = function(){
	return this.name + ' ' + this.saying
}
```


###函数化 Functional

- `Object.create` 实现继承无法保护隐私，所有属性都是可见的

**应用模块模式**

1.创建一个新对象 > 2.有选择的定义私有实例变量和方法 > 3.给新对象扩充方法 > 4.返回新对象

```js
var constructor = function(spec, my){
	var that; // 或者其他私有变量
	my = my || {};
	//把共享的变量和函数添加到my
	that =  一个新的对象
	// 给that添加特权方法
	return that;
}
```

1. `spec` 对象包含构造器需要构造一个新实例的所有信息，可能被复制到私有变量中，或者被其他函数改变，或者方法可以在需要的时候访问
2. 当构造器不需要整个 `spec` 对象时，可以将 `spec` 对象替换为一个单一的值
3. `my` 对象是为继承链中的构造器提供秘密共享的容器
4. 构造器内部函数和变量变成了该实例的私有成员，内部函数可以访问 `spec` `my` `that` 或者其他私有变量
5. 通过赋值语句给 `my` 添加共享的秘密成员
6. 扩充 `that` 加入组成该对象接口的特权方法，将函数定义为私有方法，然后分配给 `that`