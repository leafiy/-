##新API

###requestAnimationFrame()

- `requestAnimationFrame()` 接收一个参数：在重绘屏幕前调用一个函数。告知浏览器在刷新下一帧时回调参数函数

```js
var requestAnimationFrame = window.requestAnimationFrame ||
window.mozRequestAnimationFrame ||
window.webkitRequestAnimationFrame ||
window.msRequestAnimationFrame;
(function repeatOften() {
    // Do whatever
    requestAnimationFrame(repeatOften);
})();

var globalID;
function repeatOften() {
  $("<div />").appendTo("body");
  globalID = requestAnimationFrame(repeatOften);
}
$("#start").on("click", function() {
  globalID = requestAnimationFrame(repeatOften);
});
$("#stop").on("click", function() {
  cancelAnimationFrame(globalID);
});
```

###Page Visibility API

- `document.hidden` 页面是否可见

```js
function handleVisibilityChange(){
	if(document.hidden || document.msHidden || document.webkitHidden){
		// return 可见
	}else{
		// return 不可见
	}
}
```

###Geolcation API

- `navigator.geolocation` API
	- `navigator.geolocation.getCurrentPosition()` 接收三个参数
		- 成功回调函数，接收一个 `Position` 对象，包含 `coords` 和 `timestamp`
		- 失败回调函数（可选）
		- 选项对象 （可选）
			- `enableHighAccuracy` 是一个布尔值，表示必须尽可能使用最准确的位置信息
			- `timeout` 是以毫秒数表示的等待位置信息的最长时间
			- `maximumAge` 表示上一次取得的坐标信息的有效时间，如果时间到则重新取得新坐标信息
	- `navigator.geolocation.watchPosition()` 跟踪用户位置，位置变化时返回标识符，用于跟踪操作，使用 `clearWatch(wathcID)` 取消跟踪

###File API

- 文件输入元素有一个 `files` 集合，在通过文件输入字段选择了文件时， `files` 对象包含一组 `File` 对象，每个对应一个文件
	- `name` 本地文件系统中的文件名
	- `size`
	- `type` MIME类型字符串
- 通过 `input` 元素的 `change` 事件读取 `files` 集合获取

####FileReader类型

- `FileReader` 实现异步文件读取
	- `readAsText(file,encoding)` 以纯文本形式读取文件，文本保存在 `result` 属性中
	- `readAsDataURL(file)` 以数据URI方式读取保存在 `result` 中
	- `readAsBinaryString(file)`
	- `readAsArrayBuffer(file)`
- `FileReader` 读取文件事件
	- `progress` 又读取了新的数据，包含 `lengthComputable` `loaded` `total` 三个属性
	- `error`
	- `load` 是否已经读完整个文件
- 文件读取过程中可以使用 `abort()` 中断并触发 `abort` 事件

####读取部分内容

```js
function blobSlice(blob, startByte, length){
	if(blob.slice){
		return blob.slice(startByte, length)
	}else if(blob.webkitSlice){
		return blob.webkitSlice(startByte, length)
	}else if(blob.mozSlice){
		return blob.mozSlice(startByte, length)
	}else{
		return null;
	}
}
```

- `blob` 对象 `blob = blobSlice(files[0],0,32)`

####对象URL

- 使用对象URL不必吧文件内容读取到JS中而直接树勇文件内容，可以用 `window.URL.createObjectURL()` 方法传入 `File` 或 `Blob` 对象
- 返回URL字符串，指向内存中的地址
- 只要有代码在引用URL就不会销毁，可以使用 `window.URL.revokeObjectURL(url)` 释放内存

```js
function createObjectURL(blob){
	if(window.URL){
		return window.URL.createObjectURL(blob);
	}else if(window.webkitURL){
		return window.webkitURL.createObjectURL(blob);
	}else{
		return null;
	}
}
```

####读取拖放的文件

- 触发 `drop` 事件时使用 `event.dataTransfer.files` 读取到被放置的文件，是 `File` 对象

####使用XHR上传文件

- 以 `FormData` 类型方式上传文件，并将 `FormData` 用 `xhr.send()` 发送

```js
var data = new FormData();
data.append('file', file);
xhr.send(data)
```

###Web计时

- `window.performance` 对象
	- `redirect` ：页面加载前的重定向次数
	- `type` ：刚刚发生的导航类型
		- `performance.navigation.TYPE_NAVIGATE（0）`：页面第一次加载
		- `performance.navigation.TYPE_RELOAD（1）`：页面重载过
		- `performance.navigation.TYPE_BACK_FORWARD（2）`：页面是通过“后退”或“前进”按钮打开的
	- `timing` 所有属性都是时间戳
		- `navigationStart` ：开始导航到当前页面的时间
		- `unloadEventStart` ：前一个页面的unload事件开始的时间。但只有在前一个页面与当前页面来自同一个域时这个属性才会有值；否则，值为0
		- `unloadEventEnd` ：前一个页面的unload事件结束的时间。但只有在前一个页面与当前页面来自同一个域时这个属性才会有值；否则，值为0
		- `redirectStart` ：到当前页面的重定向开始的时间。但只有在重定向的页面来自同一个域时这个属性才会有值；否则，值为0
		- `redirectEnd` ：到当前页面的重定向结束的时间。但只有在重定向的页面来自同一个域时这个属性才会有值；否则，值为0
		- `fetchStart`：开始通过HTTP GET取得页面的时间
		- `domainLookupStart`：开始查询当前页面DNS的时间
		- `domainLookupEnd`：查询当前页面DNS结束的时间
		- `connectStart`：浏览器尝试连接服务器的时间
		- `connectEnd`：浏览器成功连接到服务器的时间
		- `secureConnectionStart`：浏览器尝试以SSL方式连接服务器的时间。不使用SSL方式连接时，这个属性的值为0
		- `requestStart`：浏览器开始请求页面的时间
		- `responseStart`：浏览器接收到页面第一字节的时间
		- `responseEnd`：浏览器接收到页面所有内容的时间
		- `domLoading`：document.readyState变为"loading"的时间
		- `domInteractive`：document.readyState变为"interactive"的时间
		- `domContentLoadedEventStart`：发生DOMContentLoaded事件的时间
		- `domContentLoadedEventEnd`：DOMContentLoaded事件已经发生且执行完所有事件处理程序的时间
		- `domComplete`：document.readyState变为"complete"的时间
		- `loadEventStart`：发生load事件的时间
		- loadEventEnd：load事件已经发生且执行完所有事件处理程序的时间

##Web Workers

###使用web worker

- `var worker = new Worker('a.js')` 浏览器会下载 a.js，但只有Worker接收到消息才会执行文件中的代码
- `worker.postMessage('start')` 给worker传递消息，可以序列化为JSON结构的任何值
- worker 通过 `message` 和 `error` 事件与页面通信，来自worker的数据保存在 `event.data` 中
- worker 内部执行过程发生任何错误都会触发 `error` 事件
- `worker.terminate()` 立即停止worker工作

####worker全局作用域

- worker 与它错执行的js代码完全在另一个作用域，不与当前页面共享
- worker 不能访问DOM
- 当页面在worker对象上调用 `postMessage()`时，数据会以异步方式被传递给worker，进而触发worker中的 `message` 事件

```js
self.onmessage = function(event){
	var data = event.data;
	// 处理数据
	// ...
	self.postMessage(data); // 将数据发回页面
}
```