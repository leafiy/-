##事件

> JavaScript与HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript代码）与页面的外观（HTML和CSS代码）之间的松散耦合

###事件流

> 事件流描述的是从页面中接收事件的顺序

####事件冒泡

- 事件开始时由具体（层次最深的）的元素接收，然后逐级向上传播到较为不具体的节点

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<title>Document</title>
</head>
<body>
	<div class="div">click</div>
</body>
</html>
```

**如果点击了div，这个click事件会按照 div > body > html > document 顺序传播**

####事件捕获

- 不太具体的节点应该最早接收事件，最具体的节点最后接收到事件

**如果点击了div，这个click事件会按照 document > html > body > div 顺序传播**


####DOM事件流

- DOM事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段

###事件处理程序

####HTML事件处理程序

- 事件处理程序中的代码在执行是，有权访问全局作用域中的代码
- 在事件处理程序内部，`this` 指向事件的目标元素

```html
<!--输出 click-->
<input type="text" value="click" onclick="alert(this.value)">

<form method="post">
	<input type="text" name="username" value="">
	<input type="button" value="echo username" onclick="alert(username.value)">
</form>
```

> 存在一个时差问题。因为用户可能会在HTML元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件

> 这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同JavaScript引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错

####DOM0级事件处理程序

- 将一个函数赋值给一个事件处理程序属性，每个元素都由自己的事件处理程序，全部小写

```js
var btn = document.getElementById('button');
btn.onclick = function(){
	// do something
}
// 这些代码运行以前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面
// 有可能在一段时间内怎么单击都没有反应
```

- 使用DOM0级方法指定事件处理程序，被认为是元素的方法，是在元素的作用域中运行的，this应用当前元素

####DOM2级事件处理程序

- `addEventListener()` 处理指定处理程序，`removeEventListener()` 删除事件处理程序，都接收3个参数
	1. 要处理的事件名称
	2. 作为事件处理程序的函数
	3. 布尔值true，表示捕获阶段调用事件处理程序，false表示冒泡阶段调用
- DOM2级方法可以添加多个事件处理程序
- 通过 `addEventListener()` 添加的事件处理程序只能使用 `removeEventListener()` 移除，添加的匿名函数将无法移除

```js
var btn = document.getElementById('button');
btn.addEventListener('click',function(){
	alert (this.id);
},false);
btn.addEventListener('click',function(){
	alert ('ha');
},false)
btn.removeEventListener('click',function(){ // 没有作用
	alert (this.id);
},false)

var handler = function(){
	alert (this.id)
}
btn.addEventListener('click',handler,false);
btn.removeEventListener('click',handler,false); // 有效
```

> 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，不建议在事件捕获阶段注册事件处理程序

####IE事件处理程序

- `attachEvent()` `detachEvent()` 接收两个参数：事件处理程序名称、事件处理程序函数
- 事件处理程序在全局作用域中运行，`this === window // true`
- `attachEvent()` 添加多个事件是以相反的顺序被触发的

```js
var btn = document.getElementById('button');
btn.attachEvent('onclick',function(){
	alert (this.id);
})
// 第一个参数是onclick不是click
```

####夸浏览器的事件处理程序

```js
var EventUtil = {
    addHandler: function(el, type, handler) {
        if (el.addEventListener) {
            el.addEventListener(type, handler, false);
        } else if (el.attachEvent) {
            el.attachEvent('on' + type, handler);
        } else {
            el['on' + type] = handler;
        }
    },
    removeHandler: function(el, type, handler) {
        if (el.removeEventListener) {
            el.removeEventListener(type, handler, false);
        } else if (el.detachEvent) {
            el.detachEvent('on' + type, handler);
        } else {
            el['on' + type] = null;
        }
    }
}
var btn = document.getElementById('button');
EventUtil.addHandler(el,'click',handler);
EventUtil.removeHandler(el,'click',handler);
```

###事件对象

> 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有浏览器都支持event对象

####DOM中的事件对象

```js
var btn = document.getElementById('button');
btn.onclick = function(event){
	// event
}
```

|属性、方法|描述|DOM|
|--|--|--|
|bubbles	|返回布尔值，指示事件是否是起泡事件类型|2|
|cancelable	|返回布尔值，指示事件是否可拥可取消的默认动作|2|
|currentTarget	|返回其事件监听器触发该事件的元素|2|
|eventPhase	|返回事件传播的当前阶段（1为捕获2为处于目标3为冒泡）|2|
|target	|返回触发此事件的元素（事件的目标节点）|2|
|currentTarget|其事件处理程序当前正在处理事件的那个元素||
|timeStamp	|返回事件生成的日期和时间|2|
|type	|返回当前 Event 对象表示的事件的名称|2|
|defaultPrevented|为true表示已经调用了`preventDefault()`|3|
|detail|与事件相关的细节|2|
|preventDefault|取消事件的默认行为，`cancelable`为true时可用|2|
|stopImmediatePropagation|取消事件进一步捕获或冒泡，同时组织任何事件处理程序被调用|3|
|stopPropagation|取消进一步的捕获或冒泡，`buttles`为true时可用|2|
|view|与事件关联的抽象实图，等同于发生事件的`window`||

- 在事件处理程序内部，`this` 始终等于 `currentTarget`
- `target` 只包含事件的实际目标，如果直接将事件处理程序指定给目标元素，`this = currentTarget = target`

```js
document.body.onclick = function(event){
	event.currentTarget // document.body
	this // document.body
	event.target // button
}
// this和currentTarget都等于document.body，因为事件处理程序是注册到这个元素上
// target元素却等于按钮元素，因为它是click事件真正的目标
```

- `preventDefault()` 阻止特定时间的默认行为，只有 `cancelable` 为true时可用
- `stopPropagation()` 用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡

```js
var link = document.getElementById('myLink');
link.onclick = function(e){
	e.preventDefault();
}

var btn = document.getElementById('button');
btn.onclick = function(e){
	alert ('click');
	e.stopPropagation();
}
document.body.onclick = function(){
	alert ('clicked body')
}
// 点击btn时不会触发body绑定的事件

btn.onclick = function(e){
	e.eventPhase // 2
}
document.body.addEventListener('click',function(e){
	e.eventPhase // 1
},true)
document.body.onclick = function(e){
	e.eventPhase //3
}
```

> 只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完成，event对象就会被销毁

####IE的事件对象

|属性方法|说明|
|--|--|
|cancelBubble|默认值为false，设置为true就可以取消冒泡，与`stopPropagation()`相同|
|returnValue|默认true，设置为false就可以取消事件的默认行为，与`preventDefault()`相同|
|srcElement|事件的目标，与DOM的`target`相同|
|type|被触发事件的类型|

> 因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，最好还是使用event.srcElement比较保险

```js
btn.onclick = function(){
	window.event.srcElement === this // true
}
btn.attachEvent('onclick',function(e){
	e.scrElement === this // false
})
```

####跨浏览器的事件对象

```js
var EventUtil = {
    addHandler: function(el, type, handler) {
        if (el.addEventListener) {
            el.addEventListener(type, handler, false);
        } else if (el.attachEvent) {
            el.attachEvent('on' + type, handler);
        } else {
            el['on' + type] = handler;
        }
    },
    removeHandler: function(el, type, handler) {
        if (el.removeEventListener) {
            el.removeEventListener(type, handler, false);
        } else if (el.detachEvent) {
            el.detachEvent('on' + type, handler);
        } else {
            el['on' + type] = null;
        }
    },
    getEvent: function(event){
    	return event ? event : window.event;
	},
	getTarget: function(event){
		return event.target ? event.tareget : event.srcElement;
	},
	preventDefault: function(event){
		if(event.preventDefault){
			event.preventDefault();
		}else{
			event.returnValue = false;
		}
	},
	stopPropagation: function(event){
		if(event.stopPropagation){
			event.stopPropagation();
		}else{
			event.cancelBubble = true;
		}
	}
}
```

###事件类型

- UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发
- 焦点事件，当元素获得或失去焦点时触发
- 鼠标事件，当用户通过鼠标在页面上执行操作时触发
- 滚轮事件，当使用鼠标滚轮（或类似设备）时触发
- 文本事件，当在文档中输入文本时触发
- 键盘事件，当用户通过键盘在页面上执行操作时触发
- 合成事件，当为IME（Input Method Editor，输入法编辑器）输入字符时触发
- 变动（mutation）事件，当底层DOM结构发生变化时触发

####UI事件

- `load` 当页面完全加载后在 `window` 上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在 `<img>` 元素上面触发
- `unload` 当页面完全卸载后在 `window` 上面触发，当所有框架都卸载后在框架集上面触发
- `abort` 在用户停止下载过程时
- `error` 当发生JavaScript错误时在 `window` 上面触发，当无法加载图像时在 `<img>`素上面触发
- `select` 当用户选择文本框 `<input>` `<texterea>` 中的一或多个字符时触发
- `resize` 当窗口或框架的大小变化时在 `window` 或框架上面触发
- `scroll` 当用户滚动带滚动条的元素中的内容时，在该元素上面触发。`<body>`元素中所包含加载页面的滚动条

####焦点事件

- `blur` 在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它
- `focus` 在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它
- `focusin` 在元素获得焦点时触发。这个事件与HTML事件focus等价，但它冒泡
- `focusout` 在元素失去焦点时触发。这个事件是HTML事件blur的通用版本

####鼠标与滚轮事件

- `click` 在用户单击主鼠标按钮（一般是左边的按钮）或者按下回车键时触发
- `dblclick` 在用户双击主鼠标按钮（一般是左边的按钮）时触发
- `mousedown` 在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。
- `mouseenter` 在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发
- `mouseleave` 在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发
- `mousemove` 当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。
- `mouseout`在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。
- `mouseover`在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。
- `mouseup` 在用户释放鼠标按钮时触发。不能通过键盘触发这个事件

#####客户区坐标位置

```js
EventUtil.addHandler(el,'click',function(e){
	e = EventUtil.getEvent(e);
	e.clientX // 鼠标X轴位置
	e.clientY // 鼠标Y轴位置
})
// 不包括页面滚动的距离，不表示鼠标再页面上的位置
```

#####页面坐标位置

```js
EventUtil.addHandler(el,'click',function(e){
	e = EventUtil.getEvent(e);
	e.pageX // 鼠标X轴位置
	e.pageY // 鼠标Y轴位置
})
// 包括页面滚动的距离，表示鼠标再页面上的位置
```

#####屏幕坐标的位置

相对于电脑屏幕的位置 `screenX` `screenY`

#####修改键

按下鼠标时，键盘上某些键的状态 `event.shiftKey` `event.ctrlKey` `event.altKey` `event.metaKey`

#####相关元素

- `mouseover` 事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素
- `mouseout` 事件的主目标是失去光标的元素，而相关元素则是获得光标的元素

```js
EventUtil.getRelatedTarget = function(e){
	if(e.relatedTarget){
		return e.raltedTarget;
	}else if(e.toElement){
		return e.toElement;
	}else if(e.fromElement){
		return e.fromElement;
	}else{
		return null;
	}
}

EventUtil.addHandler(el,'mouseout',function(e){
	e = EventUtil.getEvent(e);
	var target = EventUtil.getTarget(event);
	var relatedTarget = EventUtil.getRelatedTarget(event);
	target.tagName // out of
	relatedTarget.tagName // in
})
```

#####鼠标按钮

- `event.button` 0-按下鼠标主键，1-按下鼠标中间键或滚轮，2-表示按下鼠标次按钮

```js
EventUtil.getButton = function(e){
	switch(e.button){
		case 0:
		case 1:
		case 3:
		case 5:
		case 7:
			return 0;
		case 2:
		case 6:
			return 2;
		case 4:
			return 1;
	}
}
```

#####鼠标滚轮事件

- `mouseWheel` 事件的 `wheelDelta` 属性正负值确定方向

```js
EventUtil.getWheelDelta = function(e){
	if(e.wheelDelta){
		return e.wheelDelta
	}else{
		return -e.detail *40
	}
}
```

#####触摸设备

- 不支持 `dblclick` 事件。双击浏览器窗口会放大画面，而且没有办法改变该行为
- 轻击可单击元素会触发 `mousemove` 事件。**如果此操作会导致内容变化，将不再有其他事件发生**；如果屏幕没有变化，会依次发生 `mousedown > mouseup > click `事件。轻击不可单击的元素不会触发任何事件。可单击元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了 `onclick` 事件处理程序的元素
- `mousemove` 事件也会触发 `mouseover` 和 `mouseout` 事件
- 两个手指放在屏幕上且页面随手指移动而滚动时会触发 `mousewheel`和 `scroll`事件

####键盘与文本事件

- `keydown` 当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。
- `keypress` 当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件
- `keyup` 当用户释放键盘上的键时触发

> 按了一下键盘上的字符键时，首先会触发keydown事件，然后紧跟着是keypress事件，最后会触发keyup事件。其中，keydown和keypress都是在文本框发生变化之前被触发的；而keyup事件则是在文本框已经发生变化之后被触发的。如果用户按下了一个字符键不放，就会重复触发keydown和keypress事件，直到用户松开该键为止

#####键码

`event.keyCode`

#####字符编码

- `event.charCode`
- 取得了字符编码之后，就可以使用 `String.fromCharCode()` 将其转换成实际的字符

#####textInput事件

- 只有可编辑区域擦能触发 `textInput` 事件
- 只有用户按下能够输入实际字符的键时才会触发
- 事件包含 `data` 属性，保存用户输入的字符（区分大小写）

- `inputMethod` 属性表述输入的方式
	- 0，表示浏览器不确定是怎么输入的
	- 1，表示是使用键盘输入的
	- 2，表示文本是粘贴进来的
	- 3，表示文本是拖放进来的
	- 4，表示文本是使用IME输入的
	- 5，表示文本是通过在表单中选择某一项输入的
	- 6，表示文本是通过手写输入的（比如使用手写笔）
	- 7，表示文本是通过语音输入的
	- 8，表示文本是通过几种方法组合输入的
	- 9，表示文本是通过脚本输入

####复合事件

> 用于处理IME的输入序列。IME（Input Method Editor）可以让用户输入在物理键盘上找不到的字符

- `compositionstart` 在IME的文本复合系统打开时触发，表示要开始输入了
- `compositionupdate` 在向输入字段中插入新字符时触发
- `compositionend` 在IME的文本复合系统关闭时触发，表示返回正常键盘输入状态


####变动事件

#####删除节点

- 在使用 `removeChild()` 或 `replaceChild()` 从DOM中删除节点时，首先会触发 `DOMNodeRemoved` 事件
- 这个事件的目标 `event.target` 是被删除的节点，`event.relatedNode` 属性中包含着对目标节点父节点的引用
- 在这个事件触发时，节点尚未从其父节点删除，因此其 `parentNode` 属性仍然指向父节点与 `event.relatedNode` 这个事件会冒泡，因而可以在DOM的任何层次上面处理它

#####插入节点

- 在使用 `appendChild()` `replaceChild()` `insertBefore()` 向DOM中插入节点时，首先会触发 `DOMNodeInserted` 事件
- 事件的目标是被插入的节点，而 `event.relatedNode` 属性中包含一个对父节点的引用
- 事件触发时，节点已经被插入到了新的父节点中。这个事件是冒泡的，因此可以在DOM的各个层次上处理它

####HTML5事件

######contextmenu事件

- 何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<div id="myDiv">click me</div>
	<ul id="myMenu" style="visibility:hidden;position:absolute">
		<li>menu1</li>
		<li>menu2</li>
		<li>menu3</li>
	</ul>
</body>
</html>
```

```js
EventUtil.addHandler(window,'load',function(e){
	var div = document.getElementById('myDiv');
	EventUtil.addHandler(div,'contextmenu',function(e){
		e = EventUtil.getEvent(e);
		EventUtil.preventDefault(e);
		var menu = document.getElementById('myMenu');
		menu.style.left = e.clientX + 'px';
		menu.style.top = e.clientY + 'px';
		menu.style.visibility = 'visible';
	})
	EventUtil.addHandler(document,'click',function(e){
		document.getElementById('myMenu').style.visibility = 'hidden';
	})
})
```

#####beforeunload事件

- 事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。不能彻底取消这个事件

```js
EventUtil.addHandler(window, 'beforeunload',function(e){
	e = EventUtil.getEvent(e);
	var msg = 'some message';
	e.returnValue = msg;
	return msg;
})
```

#####DOMContentLoaded事件

- `DOMContentLoaded` 事件在形成完整的DOM树之后就会触发，不理会图像、JavaScript文件、CSS文件，可在页面下载的早期添加事件处理程序，目标是 `document`

```js
EventUtil.addHandler(document, 'DOMContentLoaded',function(e){
	e = EventUtil.getEvent(e);
	// 加载完成
})
```

#####readystatechange事件

- `readystatechange` 事件提供与文档或元素的加载状态的有关信息，支持 `readystatechange` 的对象有一个 `readyState` 属性
	- `uninitialized` 对象存在但未初始化
	- `loading` 对象正在加载
	- `loaded` 对象加载数据完成
	- `interactive` 可以操作对象，但还没有完全加载
	- `complete` 对象已经加载完毕

#####pageshow和pagehide

> 往返缓存（back-forward cache，或bfcache），可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。如果页面位于bfcache中，那么再次打开该页面时就不会触发load事件

- `pageshow` 事件在页面显示时触发，无论该页面是否来自bfcache。在重新加载时，`pageshow` 会在 `load` 事件触发后触发；而对于bfcache中的页面，`pageshow` 会在页面状态完全恢复的那一刻触发
- **事件的目标是 `document`，但必须将其事件处理程序添加到 `window`**
- `pageshow` 事件的 `event` 对象还包含一个名为 `persisted` 的布尔值属性。如果页面被保存在了bfcache中，则这个属性的值为true；否则，这个属性的值为false

```js
(function(){
	var showCount = 0;
	EventUtil.addHandler(window, 'load', function(){
		// loaded
	})
	EventUtil.addHander(window, 'pageshow', function(event){
		shouCount++; // 页面加载次数
		event.persisted;
	})
})()
```

- `pagehide` 事件再卸载页面的时候触发，在 `unload` 之前触发
- `pagehide` 发生在 `document` 但必须添加到 `window`
- `pagehide` 的 `persisted` 表示页面在卸载之后是否会保存到bfcache中

#####hashchange事件

- `hashchange` 事件处理程序添加给 `window` 对象，URL参数列表只要变化就会被调用
- `hashchange` 的 `event` 对象应该额外包含两个属性
	- `oldURL` 参数列表变化前的**完整URL**
	- `newURL` 参数列表变化后的**完整URL**

> 最好是使用location对象来确定当前的参数列表

####设备事件

- `orientationchange` 横向纵向方向改变
- `window.orientation` 属性中可能包含3个值：0表示肖像模式，90表示向左旋转的横向模式（“主屏幕”按钮在右侧），-90表示向右旋转的横向模式（“主屏幕”按钮在左侧）
- `deviceorientation` 加速计检测设备方向变化时在 `window` 触发
	- `alpha` 在围绕z轴旋转时（即左右旋转时），y轴的度数差；是一个介于0到360之间的浮点数。
	- `beta` 在围绕x轴旋转时（即前后旋转时），z轴的度数差；是一个介于-180到180之间的浮点数。
	- `gamma` 在围绕y轴旋转时（即扭转设备时），z轴的度数差；是一个介于-90到90之间的浮点数。
	- `absolute` 布尔值，表示设备是否返回一个绝对值。
	- `compassCalibrated` 布尔值，表示设备的指南针是否校准过
- `devicemotion` 设备事件移动时触发，比如是不是拿在手里或下掉
	- `acceleration`一个包含x、y和z属性的对象，在不考虑重力的情况下，告诉你在每个方向上的加速度
	- `accelerationIncludingGravity`一个包含x、y和z属性的对象，在考虑z轴自然重力加速度的情况下，表示每个方向上的加速度
	- `interval`以毫秒表示的时间值，必须在另一个devicemotion事件触发前传入。这个值在每个事件中是一个常量
	- `rotationRate`一个包含表示方向的alpha、beta和gamma属性的对象

####触摸与手势事件

#####触摸事件

- 兼容DOM事件，包括DOM事件中常见属性 `bubbles cancelable view clientX clientY screenX screenY detail altKey shiftKey ctrlKey`
- `touchstart` 当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发
- `touchmove` 当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用 `preventDefault()`可以阻止滚动
- `touchend` 当手指从屏幕上移开时触发
- `touchcancel` 当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明
- 触摸事件对象跟踪触摸的属性
	- `touches` 表示当前跟踪的触摸操作的Touch对象的数组
	- `targetTouchs` 特定于事件目标的Touch对象的数组
	- `changeTouches` 表示自上次触摸以来发生了什么改变的Touch对象的数组
- 每个Touch对象包含
	- `clientX` 触摸目标在视口中的x坐标
	- `clientY` 触摸目标在视口中的y坐标
	- `identifier` 标识触摸的唯一ID
	- `pageX` 触摸目标在页面中的x坐标
	- `pageY` 触摸目标在页面中的y坐标
	- `screenX` 触摸目标在屏幕中的x坐标
	- `screenY` 触摸目标在屏幕中的y坐标
	- `target` 触摸的DOM节点目标
- 触摸事件的发生顺序 ` touchstart > mouseover > mousemove(一次) > mousedown > mouseup > click > touchend `

> 在touchend事件发生时，touches集合中就没有任何Touch对象了，因为不存在活动的触摸操作；此时，就必须转而使用changeTouchs集合

#####手势事件

- 只有两个手指都触摸到事件的接收容器才会触发
- `gesturestart` 当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发
- `gesturechange` 当触摸屏幕的任何一个手指的位置发生变化时触发
- `gestureend` 当任何一个手指从屏幕上面移开时触发
- `event.rotation` 属性表示手指变化引起的旋转角度
- `event.scale` 属性表示两个手指间距离的变化

###内存和性能

> 添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间

####事件委托

- 利用事件冒泡，只指定一个事件处理程序管理某一类型的所有事件 （例如click事件会冒泡到document，为document指定一个onclick事件处理程序不必给每个可单击的元素分别指定）

```html
<ul id="myLinks">
	<li id="id1">id1</li>
	<li id="id2">id2</li>
	<li id="id3">id3</li>
</ul>
```

```js
var list = document.getElementById('myLinks');
EventUtil.addHandler(list, 'click', function(e){
	e = EventUtil.getEvent(e);
	var target = Event.getTarget(e);
	switch (target.id){
		case 'id1':
			//
		break;
		case 'id2':
			//
		break;
		.....
	}
})
```

- 适合采用事件委托技术的事件包括 `click、mousedown、mouseup、keydown、keyup、keypress`
- 为 `document` 对象添加一个事件处理程序，用以处理页面上发生的某种特定类型的事件。这样做与采取传统的做法相比具有如下优点
	- `document` 对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序，只要可单击的元素呈现在页面上，就可以立即具备适当的功能
	- 在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的DOM引用更少，所花的时间也更少
	- 整个页面占用的内存空间更少，能够提升整体性能

####移除事件处理程序

- 删除元素时移除绑定的事件

###模拟事件

- 使用js在任意时刻触发特定事件

####DOM中的事件模拟

- 在 `document` 对象上使用 `createEvent()` 创建 `event` 对象
- 使用 `dispatchEvent()` 触发事件

#####自定义DOM事件

- 自定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件
- `createEvent（"CustomEvent"）` 创建新的自定义事件，返回的对象有一个名为 `initCustomEvent()` 的方法，接收如下4个参数:
	- `type`（字符串）：触发的事件类型，例如"keydown"
	- `bubbles`（布尔值）：表示事件是否应该冒泡
	- `cancelable`（布尔值）：表示事件是否可以取消
	- `detail`（对象）：任意值，保存在event对象的detail属性中

```js
EventUtil.addHandler(el, 'event', function(e){
	// e.detail
})
EventUtil.addHandler(document, 'event', function(e){
	// e.detail
})

e = document.createEvent('event');
event.initCustomEvent('event',true ,false, 'hello world');
el.dispatch(e)
```

####IE中的事件模拟 略