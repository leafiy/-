##1.迭代器和 for-of 循环

- `for-of` 语句通过方法调用来遍历各种集合

```javascript
for (let value of array){
  console.log(value);
}
```

- 可以使用 `break` `continue` `return` 语句
- 可以遍历NodeList对象
- 可以遍历字符串

```javascript
for (let char of 'string'){
  console.log(char)
}
```

- 遍历 `set` 和 `map` 对象

```javascript
let uniq = new Set(words);
for (let word of uniq){
  console.log(word)
}

for (let [key,value] of mapObj){
  console.log('key is '+ key + 'value is ' + vaule )
}
```

- 遍历对象

```javascript
for (let key of Objcet.keys(obj)){
  console.log(key + ': ' + obj[key])
}
```

- 向任意对象增加 `obj[Symbol.iterator]()` 方法后就可以遍历这个对象

```javascript
let arr = [1,2,3];
let arrIterator = arr[Symbol.iterator]();
arrIterator.next(); // {value:1,done:false}
```



## 2.生成器 Generators

- 使用 `function*` 声明
- 关键字 `yield` 类似于 `return` 但可以 `yield` 多次
- 普通函数不能暂停，生成器函数可以暂停

```javascript
function* quips(name){
  yield `你好 ${name} !`;
  yield `hahahaha`;
  if(name.startsWith('X')){
    yield `你的名字 ${name} 以X开头`
  }
}

var cat = quips('X man');
cat.next(); // {value:'你好 X man',done:false}
cat.next(); // {value:'hahahaha',done:false}
cat.next(); // {value:'你的名字 X man以X开头',done:false}
cat.next(); // {value: undefined, done: true}
```

- 当调用一个生成器时并非立即执行，而是返回一个已暂停的生成器对象
- 对生成器使用 `next()` 方法时，函数调用将其自身解冻并运行到下一个 `yield` 表达式，再次暂停
- **生成器是迭代器**，所有生成器内部都有内建的 `.next()` 方法和 `[Symbol.iterator]()` 方法的实现，只需编写循环部分
- 使用生成器：
  - 使任意对象可迭代，编写生成器遍历这个对象，运行时`yield` 每一个值，然后将这个生成器函数作为对象的 `[Symbol.iterator]()` 方法
  - 简化数组构建函数，每次根据需要逐一计算结果

```javascript
function* filter(test,iterable){
  for (let item of iterable){
    if(test(item)){
      yield item;
    }
  }
}
```

### 生成器和异步

- ​



## 3.模板字符串

- 使用 `号代替普通字符串
- 模板占位符中的代码可以是任意js表达式
- 不会自动转义特殊字符（不安全）
- 无i18N

#### 标签模板 tagged templates

- 在 ` 号之前添加一个额外的标签
- 简化函数调用

```javascript
var msg = SaferHTML`<p>${book.sender}向你示好</p>`;
// 等同于
var msg = SaferHTML(templateData,book.sender)
// templateData 是一个不可变数组，存储着模板所有的字符串部分，由JS引擎为我们创建
// 因为占位符将标签模板分割为两个字符串的部分，所以这个数组内含两个元素，形如 Object.freeze(["<p>", " has sent you a bonk.</p>"]
```

